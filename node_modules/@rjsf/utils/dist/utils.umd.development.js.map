{"version":3,"file":"utils.umd.development.js","sources":["../src/isObject.ts","../src/allowAdditionalItems.ts","../src/asNumber.ts","../src/constants.ts","../src/getUiOptions.ts","../src/canExpand.ts","../src/deepEquals.ts","../src/findSchemaDefinition.ts","../src/schema/getMatchingOption.ts","../src/schema/getFirstMatchingOption.ts","../src/guessType.ts","../src/getSchemaType.ts","../src/mergeSchemas.ts","../src/schema/retrieveSchema.ts","../src/schema/getClosestMatchingOption.ts","../src/isFixedItems.ts","../src/mergeDefaultsWithFormData.ts","../src/mergeObjects.ts","../src/isConstant.ts","../src/schema/isSelect.ts","../src/schema/isMultiSelect.ts","../src/schema/getDefaultFormState.ts","../src/isCustomWidget.ts","../src/schema/isFilesArray.ts","../src/schema/getDisplayLabel.ts","../src/schema/mergeValidationData.ts","../src/schema/sanitizeDataForNewSchema.ts","../src/schema/toIdSchema.ts","../src/schema/toPathSchema.ts","../src/createSchemaUtils.ts","../src/dataURItoBlob.ts","../src/replaceStringParameters.ts","../src/englishStringTranslator.ts","../src/enumOptionsValueForIndex.ts","../src/enumOptionsDeselectValue.ts","../src/enumOptionsIsSelected.ts","../src/enumOptionsIndexForValue.ts","../src/enumOptionsSelectValue.ts","../src/ErrorSchemaBuilder.ts","../src/rangeSpec.ts","../src/getInputProps.ts","../src/getSubmitButtonOptions.ts","../src/getTemplate.ts","../src/getWidget.tsx","../src/hasWidget.ts","../src/idGenerators.ts","../src/labelValue.ts","../src/localToUTC.ts","../src/toConstant.ts","../src/optionsList.ts","../src/orderProperties.ts","../src/pad.ts","../src/parseDateString.ts","../src/schemaRequiresTrueValue.ts","../src/shouldRender.ts","../src/toDateString.ts","../src/utcToLocal.ts","../src/enums.ts"],"sourcesContent":["/** Determines whether a `thing` is an object for the purposes of RSJF. In this case, `thing` is an object if it has\n * the type `object` but is NOT null, an array or a File.\n *\n * @param thing - The thing to check to see whether it is an object\n * @returns - True if it is a non-null, non-array, non-File object\n */\nexport default function isObject(thing: any) {\n  if (typeof File !== 'undefined' && thing instanceof File) {\n    return false;\n  }\n  if (typeof Date !== 'undefined' && thing instanceof Date) {\n    return false;\n  }\n  return typeof thing === 'object' && thing !== null && !Array.isArray(thing);\n}\n","import isObject from './isObject';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Checks the schema to see if it is allowing additional items, by verifying that `schema.additionalItems` is an\n * object. The user is warned in the console if `schema.additionalItems` has the value `true`.\n *\n * @param schema - The schema object to check\n * @returns - True if additional items is allowed, otherwise false\n */\nexport default function allowAdditionalItems<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  if (schema.additionalItems === true) {\n    console.warn('additionalItems=true is currently not supported');\n  }\n  return isObject(schema.additionalItems);\n}\n","/** Attempts to convert the string into a number. If an empty string is provided, then `undefined` is returned. If a\n * `null` is provided, it is returned. If the string ends in a `.` then the string is returned because the user may be\n * in the middle of typing a float number. If a number ends in a pattern like `.0`, `.20`, `.030`, string is returned\n * because the user may be typing number that will end in a non-zero digit. Otherwise, the string is wrapped by\n * `Number()` and if that result is not `NaN`, that number will be returned, otherwise the string `value` will be.\n *\n * @param value - The string or null value to convert to a number\n * @returns - The `value` converted to a number when appropriate, otherwise the `value`\n */\nexport default function asNumber(value: string | null) {\n  if (value === '') {\n    return undefined;\n  }\n  if (value === null) {\n    return null;\n  }\n  if (/\\.$/.test(value)) {\n    // '3.' can't really be considered a number even if it parses in js. The\n    // user is most likely entering a float.\n    return value;\n  }\n  if (/\\.0$/.test(value)) {\n    // we need to return this as a string here, to allow for input like 3.07\n    return value;\n  }\n\n  if (/\\.\\d*0$/.test(value)) {\n    // It's a number, that's cool - but we need it as a string so it doesn't screw\n    // with the user when entering dollar amounts or other values (such as those with\n    // specific precision or number of significant digits)\n    return value;\n  }\n\n  const n = Number(value);\n  const valid = typeof n === 'number' && !Number.isNaN(n);\n\n  return valid ? n : value;\n}\n","/** Below are the list of all the keys into various elements of a RJSFSchema or UiSchema that are used by the various\n * utility functions. In addition to those keys, there are the special `ADDITIONAL_PROPERTY_FLAG` and\n * `RJSF_ADDITONAL_PROPERTIES_FLAG` flags that is added to a schema under certain conditions by the `retrieveSchema()`\n * utility.\n */\nexport const ADDITIONAL_PROPERTY_FLAG = '__additional_property';\nexport const ADDITIONAL_PROPERTIES_KEY = 'additionalProperties';\nexport const ALL_OF_KEY = 'allOf';\nexport const ANY_OF_KEY = 'anyOf';\nexport const CONST_KEY = 'const';\nexport const DEFAULT_KEY = 'default';\nexport const DEFINITIONS_KEY = 'definitions';\nexport const DEPENDENCIES_KEY = 'dependencies';\nexport const ENUM_KEY = 'enum';\nexport const ERRORS_KEY = '__errors';\nexport const ID_KEY = '$id';\nexport const ITEMS_KEY = 'items';\nexport const NAME_KEY = '$name';\nexport const ONE_OF_KEY = 'oneOf';\nexport const PROPERTIES_KEY = 'properties';\nexport const REQUIRED_KEY = 'required';\nexport const SUBMIT_BTN_OPTIONS_KEY = 'submitButtonOptions';\nexport const REF_KEY = '$ref';\nexport const RJSF_ADDITONAL_PROPERTIES_FLAG = '__rjsf_additionalProperties';\nexport const UI_FIELD_KEY = 'ui:field';\nexport const UI_WIDGET_KEY = 'ui:widget';\nexport const UI_OPTIONS_KEY = 'ui:options';\nexport const UI_GLOBAL_OPTIONS_KEY = 'ui:globalOptions';\n","import { UI_OPTIONS_KEY, UI_WIDGET_KEY } from './constants';\nimport isObject from './isObject';\nimport { FormContextType, GlobalUISchemaOptions, RJSFSchema, StrictRJSFSchema, UIOptionsType, UiSchema } from './types';\n\n/** Get all passed options from ui:options, and ui:<optionName>, returning them in an object with the `ui:`\n * stripped off. Any `globalOptions` will always be returned, unless they are overridden by options in the `uiSchema`.\n *\n * @param [uiSchema={}] - The UI Schema from which to get any `ui:xxx` options\n * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options\n * @returns - An object containing all the `ui:xxx` options with the `ui:` stripped off along with all `globalOptions`\n */\nexport default function getUiOptions<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  uiSchema: UiSchema<T, S, F> = {},\n  globalOptions: GlobalUISchemaOptions = {}\n): UIOptionsType<T, S, F> {\n  return Object.keys(uiSchema)\n    .filter((key) => key.indexOf('ui:') === 0)\n    .reduce(\n      (options, key) => {\n        const value = uiSchema[key];\n        if (key === UI_WIDGET_KEY && isObject(value)) {\n          console.error('Setting options via ui:widget object is no longer supported, use ui:options instead');\n          return options;\n        }\n        if (key === UI_OPTIONS_KEY && isObject(value)) {\n          return { ...options, ...value };\n        }\n        return { ...options, [key.substring(3)]: value };\n      },\n      { ...globalOptions }\n    );\n}\n","import { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema } from './types';\nimport getUiOptions from './getUiOptions';\n\n/** Checks whether the field described by `schema`, having the `uiSchema` and `formData` supports expanding. The UI for\n * the field can expand if it has additional properties, is not forced as non-expandable by the `uiSchema` and the\n * `formData` object doesn't already have `schema.maxProperties` elements.\n *\n * @param schema - The schema for the field that is being checked\n * @param [uiSchema={}] - The uiSchema for the field\n * @param [formData] - The formData for the field\n * @returns - True if the schema element has additionalProperties, is expandable, and not at the maxProperties limit\n */\nexport default function canExpand<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  schema: RJSFSchema,\n  uiSchema: UiSchema<T, S, F> = {},\n  formData?: T\n) {\n  if (!schema.additionalProperties) {\n    return false;\n  }\n  const { expandable = true } = getUiOptions<T, S, F>(uiSchema);\n  if (expandable === false) {\n    return expandable;\n  }\n  // if ui:options.expandable was not explicitly set to false, we can add\n  // another property if we have not exceeded maxProperties yet\n  if (schema.maxProperties !== undefined && formData) {\n    return Object.keys(formData).length < schema.maxProperties;\n  }\n  return true;\n}\n","import isEqualWith from 'lodash/isEqualWith';\n\n/** Implements a deep equals using the `lodash.isEqualWith` function, that provides a customized comparator that\n * assumes all functions are equivalent.\n *\n * @param a - The first element to compare\n * @param b - The second element to compare\n * @returns - True if the `a` and `b` are deeply equal, false otherwise\n */\nexport default function deepEquals(a: any, b: any): boolean {\n  return isEqualWith(a, b, (obj: any, other: any) => {\n    if (typeof obj === 'function' && typeof other === 'function') {\n      // Assume all functions are equivalent\n      // see https://github.com/rjsf-team/react-jsonschema-form/issues/255\n      return true;\n    }\n    return undefined; // fallback to default isEquals behavior\n  });\n}\n","import jsonpointer from 'jsonpointer';\nimport omit from 'lodash/omit';\n\nimport { REF_KEY } from './constants';\nimport { GenericObjectType, RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Splits out the value at the `key` in `object` from the `object`, returning an array that contains in the first\n * location, the `object` minus the `key: value` and in the second location the `value`.\n *\n * @param key - The key from the object to extract\n * @param object - The object from which to extract the element\n * @returns - An array with the first value being the object minus the `key` element and the second element being the\n *      value from `object[key]`\n */\nexport function splitKeyElementFromObject(key: string, object: GenericObjectType) {\n  const value = object[key];\n  const remaining = omit(object, [key]);\n  return [remaining, value];\n}\n\n/** Given the name of a `$ref` from within a schema, using the `rootSchema`, look up and return the sub-schema using the\n * path provided by that reference. If `#` is not the first character of the reference, or the path does not exist in\n * the schema, then throw an Error. Otherwise return the sub-schema. Also deals with nested `$ref`s in the sub-schema.\n *\n * @param $ref - The ref string for which the schema definition is desired\n * @param [rootSchema={}] - The root schema in which to search for the definition\n * @returns - The sub-schema within the `rootSchema` which matches the `$ref` if it exists\n * @throws - Error indicating that no schema for that reference exists\n */\nexport default function findSchemaDefinition<S extends StrictRJSFSchema = RJSFSchema>(\n  $ref?: string,\n  rootSchema: S = {} as S\n): S {\n  let ref = $ref || '';\n  if (ref.startsWith('#')) {\n    // Decode URI fragment representation.\n    ref = decodeURIComponent(ref.substring(1));\n  } else {\n    throw new Error(`Could not find a definition for ${$ref}.`);\n  }\n  const current: S = jsonpointer.get(rootSchema, ref);\n  if (current === undefined) {\n    throw new Error(`Could not find a definition for ${$ref}.`);\n  }\n  if (current[REF_KEY]) {\n    const [remaining, theRef] = splitKeyElementFromObject(REF_KEY, current);\n    const subSchema = findSchemaDefinition<S>(theRef, rootSchema);\n    if (Object.keys(remaining).length > 0) {\n      return { ...remaining, ...subSchema };\n    }\n    return subSchema;\n  }\n  return current;\n}\n","import { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\n\n/** Given the `formData` and list of `options`, attempts to find the index of the option that best matches the data.\n * Deprecated, use `getFirstMatchingOption()` instead.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param formData - The current formData, if any, used to figure out a match\n * @param options - The list of options to find a matching options from\n * @param rootSchema - The root schema, used to primarily to look up `$ref`s\n * @returns - The index of the matched option or 0 if none is available\n * @deprecated\n */\nexport default function getMatchingOption<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, formData: T | undefined, options: S[], rootSchema: S): number {\n  // For performance, skip validating subschemas if formData is undefined. We just\n  // want to get the first option in that case.\n  if (formData === undefined) {\n    return 0;\n  }\n  for (let i = 0; i < options.length; i++) {\n    const option = options[i];\n\n    // If the schema describes an object then we need to add slightly more\n    // strict matching to the schema, because unless the schema uses the\n    // \"requires\" keyword, an object will match the schema as long as it\n    // doesn't have matching keys with a conflicting type. To do this we use an\n    // \"anyOf\" with an array of requires. This augmentation expresses that the\n    // schema should match if any of the keys in the schema are present on the\n    // object and pass validation.\n    if (option.properties) {\n      // Create an \"anyOf\" schema that requires at least one of the keys in the\n      // \"properties\" object\n      const requiresAnyOf = {\n        anyOf: Object.keys(option.properties).map((key) => ({\n          required: [key],\n        })),\n      };\n\n      let augmentedSchema;\n\n      // If the \"anyOf\" keyword already exists, wrap the augmentation in an \"allOf\"\n      if (option.anyOf) {\n        // Create a shallow clone of the option\n        const { ...shallowClone } = option;\n\n        if (!shallowClone.allOf) {\n          shallowClone.allOf = [];\n        } else {\n          // If \"allOf\" already exists, shallow clone the array\n          shallowClone.allOf = shallowClone.allOf.slice();\n        }\n\n        shallowClone.allOf.push(requiresAnyOf);\n\n        augmentedSchema = shallowClone;\n      } else {\n        augmentedSchema = Object.assign({}, option, requiresAnyOf);\n      }\n\n      // Remove the \"required\" field as it's likely that not all fields have\n      // been filled in yet, which will mean that the schema is not valid\n      delete augmentedSchema.required;\n\n      if (validator.isValid(augmentedSchema, formData, rootSchema)) {\n        return i;\n      }\n    } else if (validator.isValid(option, formData, rootSchema)) {\n      return i;\n    }\n  }\n  return 0;\n}\n","import getMatchingOption from './getMatchingOption';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\n\n/** Given the `formData` and list of `options`, attempts to find the index of the first option that matches the data.\n * Always returns the first option if there is nothing that matches.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param formData - The current formData, if any, used to figure out a match\n * @param options - The list of options to find a matching options from\n * @param rootSchema - The root schema, used to primarily to look up `$ref`s\n * @returns - The index of the first matched option or 0 if none is available\n */\nexport default function getFirstMatchingOption<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, formData: T | undefined, options: S[], rootSchema: S): number {\n  return getMatchingOption<T, S, F>(validator, formData, options, rootSchema);\n}\n","/** Given a specific `value` attempts to guess the type of a schema element. In the case where we have to implicitly\n *  create a schema, it is useful to know what type to use based on the data we are defining.\n *\n * @param value - The value from which to guess the type\n * @returns - The best guess for the object type\n */\nexport default function guessType(value: any) {\n  if (Array.isArray(value)) {\n    return 'array';\n  }\n  if (typeof value === 'string') {\n    return 'string';\n  }\n  if (value == null) {\n    return 'null';\n  }\n  if (typeof value === 'boolean') {\n    return 'boolean';\n  }\n  if (!isNaN(value)) {\n    return 'number';\n  }\n  if (typeof value === 'object') {\n    return 'object';\n  }\n  // Default to string if we can't figure it out\n  return 'string';\n}\n","import guessType from './guessType';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Gets the type of a given `schema`. If the type is not explicitly defined, then an attempt is made to infer it from\n * other elements of the schema as follows:\n * - schema.const: Returns the `guessType()` of that value\n * - schema.enum: Returns `string`\n * - schema.properties: Returns `object`\n * - schema.additionalProperties: Returns `object`\n * - type is an array with a length of 2 and one type is 'null': Returns the other type\n *\n * @param schema - The schema for which to get the type\n * @returns - The type of the schema\n */\nexport default function getSchemaType<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S\n): string | string[] | undefined {\n  let { type } = schema;\n\n  if (!type && schema.const) {\n    return guessType(schema.const);\n  }\n\n  if (!type && schema.enum) {\n    return 'string';\n  }\n\n  if (!type && (schema.properties || schema.additionalProperties)) {\n    return 'object';\n  }\n\n  if (Array.isArray(type) && type.length === 2 && type.includes('null')) {\n    type = type.find((type) => type !== 'null');\n  }\n\n  return type;\n}\n","import union from 'lodash/union';\n\nimport { REQUIRED_KEY } from './constants';\nimport getSchemaType from './getSchemaType';\nimport isObject from './isObject';\nimport { GenericObjectType } from './types';\n\n/** Recursively merge deeply nested schemas. The difference between `mergeSchemas` and `mergeObjects` is that\n * `mergeSchemas` only concats arrays for values under the 'required' keyword, and when it does, it doesn't include\n * duplicate values.\n *\n * @param obj1 - The first schema object to merge\n * @param obj2 - The second schema object to merge\n * @returns - The merged schema object\n */\nexport default function mergeSchemas(obj1: GenericObjectType, obj2: GenericObjectType) {\n  const acc = Object.assign({}, obj1); // Prevent mutation of source object.\n  return Object.keys(obj2).reduce((acc, key) => {\n    const left = obj1 ? obj1[key] : {},\n      right = obj2[key];\n    if (obj1 && key in obj1 && isObject(right)) {\n      acc[key] = mergeSchemas(left, right);\n    } else if (\n      obj1 &&\n      obj2 &&\n      (getSchemaType(obj1) === 'object' || getSchemaType(obj2) === 'object') &&\n      key === REQUIRED_KEY &&\n      Array.isArray(left) &&\n      Array.isArray(right)\n    ) {\n      // Don't include duplicate values when merging 'required' fields.\n      acc[key] = union(left, right);\n    } else {\n      acc[key] = right;\n    }\n    return acc;\n  }, acc);\n}\n","import get from 'lodash/get';\nimport set from 'lodash/set';\nimport mergeAllOf, { Options } from 'json-schema-merge-allof';\n\nimport {\n  ADDITIONAL_PROPERTIES_KEY,\n  ADDITIONAL_PROPERTY_FLAG,\n  ALL_OF_KEY,\n  ANY_OF_KEY,\n  DEPENDENCIES_KEY,\n  ONE_OF_KEY,\n  REF_KEY,\n} from '../constants';\nimport findSchemaDefinition, { splitKeyElementFromObject } from '../findSchemaDefinition';\nimport guessType from '../guessType';\nimport isObject from '../isObject';\nimport mergeSchemas from '../mergeSchemas';\nimport { FormContextType, GenericObjectType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport getFirstMatchingOption from './getFirstMatchingOption';\n\n/** Resolves a conditional block (if/else/then) by removing the condition and merging the appropriate conditional branch\n * with the rest of the schema\n *\n * @param validator - An implementation of the `ValidatorType<T, S>` interface that is used to detect valid schema conditions\n * @param schema - The schema for which resolving a condition is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param [formData] - The current formData to assist retrieving a schema\n * @returns - A schema with the appropriate condition resolved\n */\nexport function resolveCondition<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  formData?: T\n) {\n  const { if: expression, then, else: otherwise, ...resolvedSchemaLessConditional } = schema;\n\n  const conditionalSchema = validator.isValid(expression as S, formData, rootSchema) ? then : otherwise;\n\n  if (conditionalSchema && typeof conditionalSchema !== 'boolean') {\n    return retrieveSchema<T, S>(\n      validator,\n      mergeSchemas(\n        resolvedSchemaLessConditional,\n        retrieveSchema<T, S, F>(validator, conditionalSchema as S, rootSchema, formData)\n      ) as S,\n      rootSchema,\n      formData\n    );\n  }\n  return retrieveSchema<T, S, F>(validator, resolvedSchemaLessConditional as S, rootSchema, formData);\n}\n\n/** Resolves references and dependencies within a schema and its 'allOf' children.\n * Called internally by retrieveSchema.\n *\n * @param validator - An implementation of the `ValidatorType<T, S>` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a schema is desired\n * @param [rootSchema={}] - The root schema that will be forwarded to all the APIs\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The schema having its references and dependencies resolved\n */\nexport function resolveSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S = {} as S,\n  formData?: T\n): S {\n  if (REF_KEY in schema) {\n    return resolveReference<T, S, F>(validator, schema, rootSchema, formData);\n  }\n  if (DEPENDENCIES_KEY in schema) {\n    const resolvedSchema = resolveDependencies<T, S, F>(validator, schema, rootSchema, formData);\n    return retrieveSchema<T, S, F>(validator, resolvedSchema, rootSchema, formData);\n  }\n  if (ALL_OF_KEY in schema) {\n    return {\n      ...schema,\n      allOf: schema.allOf!.map((allOfSubschema) =>\n        retrieveSchema<T, S, F>(validator, allOfSubschema as S, rootSchema, formData)\n      ),\n    };\n  }\n  // No $ref or dependencies attribute found, returning the original schema.\n  return schema;\n}\n\n/** Resolves references within a schema and its 'allOf' children.\n *\n * @param validator - An implementation of the `ValidatorType<T, S>` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a reference is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The schema having its references resolved\n */\nexport function resolveReference<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  formData?: T\n): S {\n  // Retrieve the referenced schema definition.\n  const $refSchema = findSchemaDefinition<S>(schema.$ref, rootSchema);\n  // Drop the $ref property of the source schema.\n  const { $ref, ...localSchema } = schema;\n  // Update referenced schema definition with local schema properties.\n  return retrieveSchema<T, S, F>(validator, { ...$refSchema, ...localSchema }, rootSchema, formData);\n}\n\n/** Creates new 'properties' items for each key in the `formData`\n *\n * @param validator - An implementation of the `ValidatorType<T, S>` interface that will be used when necessary\n * @param theSchema - The schema for which the existing additional properties is desired\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s * @param validator\n * @param [aFormData] - The current formData, if any, to assist retrieving a schema\n * @returns - The updated schema with additional properties stubbed\n */\nexport function stubExistingAdditionalProperties<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, theSchema: S, rootSchema?: S, aFormData?: T): S {\n  // Clone the schema so we don't ruin the consumer's original\n  const schema = {\n    ...theSchema,\n    properties: { ...theSchema.properties },\n  };\n\n  // make sure formData is an object\n  const formData: GenericObjectType = aFormData && isObject(aFormData) ? aFormData : {};\n  Object.keys(formData).forEach((key) => {\n    if (key in schema.properties) {\n      // No need to stub, our schema already has the property\n      return;\n    }\n\n    let additionalProperties: S['additionalProperties'] = {};\n    if (typeof schema.additionalProperties !== 'boolean') {\n      if (REF_KEY in schema.additionalProperties!) {\n        additionalProperties = retrieveSchema<T, S, F>(\n          validator,\n          { $ref: get(schema.additionalProperties, [REF_KEY]) } as S,\n          rootSchema,\n          formData as T\n        );\n      } else if ('type' in schema.additionalProperties!) {\n        additionalProperties = { ...schema.additionalProperties };\n      } else if (ANY_OF_KEY in schema.additionalProperties! || ONE_OF_KEY in schema.additionalProperties!) {\n        additionalProperties = {\n          type: 'object',\n          ...schema.additionalProperties,\n        };\n      } else {\n        additionalProperties = { type: guessType(get(formData, [key])) };\n      }\n    } else {\n      additionalProperties = { type: guessType(get(formData, [key])) };\n    }\n\n    // The type of our new key should match the additionalProperties value;\n    schema.properties[key] = additionalProperties;\n    // Set our additional property flag so we know it was dynamically added\n    set(schema.properties, [key, ADDITIONAL_PROPERTY_FLAG], true);\n  });\n\n  return schema;\n}\n\n/** Retrieves an expanded schema that has had all of its conditions, additional properties, references and dependencies\n * resolved and merged into the `schema` given a `validator`, `rootSchema` and `rawFormData` that is used to do the\n * potentially recursive resolution.\n *\n * @param validator - An implementation of the `ValidatorType<T, S>` interface that will be forwarded to all the APIs\n * @param schema - The schema for which retrieving a schema is desired\n * @param [rootSchema={}] - The root schema that will be forwarded to all the APIs\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\n * @returns - The schema having its conditions, additional properties, references and dependencies resolved\n */\nexport default function retrieveSchema<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, schema: S, rootSchema: S = {} as S, rawFormData?: T): S {\n  if (!isObject(schema)) {\n    return {} as S;\n  }\n  let resolvedSchema = resolveSchema<T, S, F>(validator, schema, rootSchema, rawFormData);\n\n  if ('if' in schema) {\n    return resolveCondition<T, S, F>(validator, schema, rootSchema, rawFormData as T);\n  }\n\n  const formData: GenericObjectType = rawFormData || {};\n\n  if (ALL_OF_KEY in schema) {\n    try {\n      resolvedSchema = mergeAllOf(resolvedSchema, {\n        deep: false,\n      } as Options) as S;\n    } catch (e) {\n      console.warn('could not merge subschemas in allOf:\\n' + e);\n      const { allOf, ...resolvedSchemaWithoutAllOf } = resolvedSchema;\n      return resolvedSchemaWithoutAllOf as S;\n    }\n  }\n  const hasAdditionalProperties =\n    ADDITIONAL_PROPERTIES_KEY in resolvedSchema && resolvedSchema.additionalProperties !== false;\n  if (hasAdditionalProperties) {\n    return stubExistingAdditionalProperties<T, S, F>(validator, resolvedSchema, rootSchema, formData as T);\n  }\n  return resolvedSchema;\n}\n\n/** Resolves dependencies within a schema and its 'allOf' children.\n *\n * @param validator - An implementation of the `ValidatorType<T, S>` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a dependency is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The schema with its dependencies resolved\n */\nexport function resolveDependencies<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  formData?: T\n): S {\n  // Drop the dependencies from the source schema.\n  const { dependencies, ...remainingSchema } = schema;\n  let resolvedSchema: S = remainingSchema as S;\n  if (Array.isArray(resolvedSchema.oneOf)) {\n    resolvedSchema = resolvedSchema.oneOf[\n      getFirstMatchingOption<T, S, F>(validator, formData, resolvedSchema.oneOf as S[], rootSchema)\n    ] as S;\n  } else if (Array.isArray(resolvedSchema.anyOf)) {\n    resolvedSchema = resolvedSchema.anyOf[\n      getFirstMatchingOption<T, S, F>(validator, formData, resolvedSchema.anyOf as S[], rootSchema)\n    ] as S;\n  }\n  return processDependencies<T, S, F>(validator, dependencies, resolvedSchema, rootSchema, formData);\n}\n\n/** Processes all the `dependencies` recursively into the `resolvedSchema` as needed\n *\n * @param validator - An implementation of the `ValidatorType<T, S>` interface that will be forwarded to all the APIs\n * @param dependencies - The set of dependencies that needs to be processed\n * @param resolvedSchema - The schema for which processing dependencies is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The schema with the `dependencies` resolved into it\n */\nexport function processDependencies<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  dependencies: S['dependencies'],\n  resolvedSchema: S,\n  rootSchema: S,\n  formData?: T\n): S {\n  let schema = resolvedSchema;\n  // Process dependencies updating the local schema properties as appropriate.\n  for (const dependencyKey in dependencies) {\n    // Skip this dependency if its trigger property is not present.\n    if (get(formData, [dependencyKey]) === undefined) {\n      continue;\n    }\n    // Skip this dependency if it is not included in the schema (such as when dependencyKey is itself a hidden dependency.)\n    if (schema.properties && !(dependencyKey in schema.properties)) {\n      continue;\n    }\n    const [remainingDependencies, dependencyValue] = splitKeyElementFromObject(\n      dependencyKey,\n      dependencies as GenericObjectType\n    );\n    if (Array.isArray(dependencyValue)) {\n      schema = withDependentProperties<S>(schema, dependencyValue);\n    } else if (isObject(dependencyValue)) {\n      schema = withDependentSchema<T, S, F>(\n        validator,\n        schema,\n        rootSchema,\n        dependencyKey,\n        dependencyValue as S,\n        formData\n      );\n    }\n    return processDependencies<T, S, F>(validator, remainingDependencies, schema, rootSchema, formData);\n  }\n  return schema;\n}\n\n/** Updates a schema with additionally required properties added\n *\n * @param schema - The schema for which resolving a dependent properties is desired\n * @param [additionallyRequired] - An optional array of additionally required names\n * @returns - The schema with the additional required values merged in\n */\nexport function withDependentProperties<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S,\n  additionallyRequired?: string[]\n) {\n  if (!additionallyRequired) {\n    return schema;\n  }\n  const required = Array.isArray(schema.required)\n    ? Array.from(new Set([...schema.required, ...additionallyRequired]))\n    : additionallyRequired;\n  return { ...schema, required: required };\n}\n\n/** Merges a dependent schema into the `schema` dealing with oneOfs and references\n *\n * @param validator - An implementation of the `ValidatorType<T, S>` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a dependent schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param dependencyKey - The key name of the dependency\n * @param dependencyValue - The potentially dependent schema\n * @param formData- The current formData to assist retrieving a schema\n * @returns - The schema with the dependent schema resolved into it\n */\nexport function withDependentSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  dependencyKey: string,\n  dependencyValue: S,\n  formData?: T\n) {\n  const { oneOf, ...dependentSchema } = retrieveSchema<T, S, F>(validator, dependencyValue, rootSchema, formData);\n  schema = mergeSchemas(schema, dependentSchema) as S;\n  // Since it does not contain oneOf, we return the original schema.\n  if (oneOf === undefined) {\n    return schema;\n  }\n  // Resolve $refs inside oneOf.\n  const resolvedOneOf = oneOf.map((subschema) => {\n    if (typeof subschema === 'boolean' || !(REF_KEY in subschema)) {\n      return subschema;\n    }\n    return resolveReference<T, S, F>(validator, subschema as S, rootSchema, formData);\n  });\n  return withExactlyOneSubschema<T, S, F>(validator, schema, rootSchema, dependencyKey, resolvedOneOf, formData);\n}\n\n/** Returns a `schema` with the best choice from the `oneOf` options merged into it\n *\n * @param validator - An implementation of the `ValidatorType<T, S>` interface that will be used to validate oneOf options\n * @param schema - The schema for which resolving a oneOf subschema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param dependencyKey - The key name of the oneOf dependency\n * @param oneOf - The list of schemas representing the oneOf options\n * @param [formData] - The current formData to assist retrieving a schema\n * @returns  The schema with the best choice of oneOf schemas merged into\n */\nexport function withExactlyOneSubschema<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  dependencyKey: string,\n  oneOf: S['oneOf'],\n  formData?: T\n): S {\n  const validSubschemas = oneOf!.filter((subschema) => {\n    if (typeof subschema === 'boolean' || !subschema || !subschema.properties) {\n      return false;\n    }\n    const { [dependencyKey]: conditionPropertySchema } = subschema.properties;\n    if (conditionPropertySchema) {\n      const conditionSchema: S = {\n        type: 'object',\n        properties: {\n          [dependencyKey]: conditionPropertySchema,\n        },\n      } as S;\n      const { errors } = validator.validateFormData(formData, conditionSchema);\n      return errors.length === 0;\n    }\n    return false;\n  });\n\n  if (validSubschemas!.length !== 1) {\n    console.warn(\"ignoring oneOf in dependencies because there isn't exactly one subschema that is valid\");\n    return schema;\n  }\n  const subschema: S = validSubschemas[0] as S;\n  const [dependentSubschema] = splitKeyElementFromObject(dependencyKey, subschema.properties as GenericObjectType);\n  const dependentSchema = { ...subschema, properties: dependentSubschema };\n  return mergeSchemas(schema, retrieveSchema<T, S>(validator, dependentSchema, rootSchema, formData)) as S;\n}\n","import get from 'lodash/get';\nimport has from 'lodash/has';\nimport isObject from 'lodash/isObject';\nimport isString from 'lodash/isString';\nimport reduce from 'lodash/reduce';\nimport times from 'lodash/times';\n\nimport getFirstMatchingOption from './getFirstMatchingOption';\nimport retrieveSchema from './retrieveSchema';\nimport { ONE_OF_KEY, REF_KEY } from '../constants';\nimport guessType from '../guessType';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\n\n/** A junk option used to determine when the getFirstMatchingOption call really matches an option rather than returning\n * the first item\n */\nexport const JUNK_OPTION: StrictRJSFSchema = {\n  type: 'object',\n  properties: {\n    __not_really_there__: {\n      type: 'number',\n    },\n  },\n};\n\n/** Recursive function that calculates the score of a `formData` against the given `schema`. The computation is fairly\n * simple. Initially the total score is 0. When `schema.properties` object exists, then all the `key/value` pairs within\n * the object are processed as follows after obtaining the formValue from `formData` using the `key`:\n * - If the `value` contains a `$ref`, `calculateIndexScore()` is called recursively with the formValue and the new\n *   schema that is the result of the ref in the schema being resolved and that sub-schema's resulting score is added to\n *   the total.\n * - If the `value` contains a `oneOf` and there is a formValue, then score based on the index returned from calling\n *   `getClosestMatchingOption()` of that oneOf.\n * - If the type of the `value` is 'object', `calculateIndexScore()` is called recursively with the formValue and the\n *   `value` itself as the sub-schema, and the score is added to the total.\n * - If the type of the `value` matches the guessed-type of the `formValue`, the score is incremented by 1, UNLESS the\n *   value has a `default` or `const`. In those case, if the `default` or `const` and the `formValue` match, the score\n *   is incremented by another 1 otherwise it is decremented by 1.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param rootSchema - The root JSON schema of the entire form\n * @param schema - The schema for which the score is being calculated\n * @param formData - The form data associated with the schema, used to calculate the score\n * @returns - The score a schema against the formData\n */\nexport function calculateIndexScore<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  rootSchema: S,\n  schema?: S,\n  formData: any = {}\n): number {\n  let totalScore = 0;\n  if (schema) {\n    if (isObject(schema.properties)) {\n      totalScore += reduce(\n        schema.properties,\n        (score, value, key) => {\n          const formValue = get(formData, key);\n          if (typeof value === 'boolean') {\n            return score;\n          }\n          if (has(value, REF_KEY)) {\n            const newSchema = retrieveSchema<T, S, F>(validator, value as S, rootSchema, formValue);\n            return score + calculateIndexScore<T, S, F>(validator, rootSchema, newSchema, formValue || {});\n          }\n          if (has(value, ONE_OF_KEY) && formValue) {\n            return (\n              score + getClosestMatchingOption<T, S, F>(validator, rootSchema, formValue, get(value, ONE_OF_KEY) as S[])\n            );\n          }\n          if (value.type === 'object') {\n            return score + calculateIndexScore<T, S, F>(validator, rootSchema, value as S, formValue || {});\n          }\n          if (value.type === guessType(formValue)) {\n            // If the types match, then we bump the score by one\n            let newScore = score + 1;\n            if (value.default) {\n              // If the schema contains a readonly default value score the value that matches the default higher and\n              // any non-matching value lower\n              newScore += formValue === value.default ? 1 : -1;\n            } else if (value.const) {\n              // If the schema contains a const value score the value that matches the default higher and\n              // any non-matching value lower\n              newScore += formValue === value.const ? 1 : -1;\n            }\n            // TODO eventually, deal with enums/arrays\n            return newScore;\n          }\n          return score;\n        },\n        0\n      );\n    } else if (isString(schema.type) && schema.type === guessType(formData)) {\n      totalScore += 1;\n    }\n  }\n  return totalScore;\n}\n\n/** Determines which of the given `options` provided most closely matches the `formData`. Using\n * `getFirstMatchingOption()` to match two schemas that differ only by the readOnly, default or const value of a field\n * based on the `formData` and returns 0 when there is no match. Rather than passing in all the `options` at once to\n * this utility, instead an array of valid option indexes is created by iterating over the list of options, call\n * `getFirstMatchingOptions` with a list of one junk option and one good option, seeing if the good option is considered\n * matched.\n *\n * Once the list of valid indexes is created, if there is only one valid index, just return it. Otherwise, if there are\n * no valid indexes, then fill the valid indexes array with the indexes of all the options. Next, the index of the\n * option with the highest score is determined by iterating over the list of valid options, calling\n * `calculateIndexScore()` on each, comparing it against the current best score, and returning the index of the one that\n * eventually has the best score.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param rootSchema - The root JSON schema of the entire form\n * @param formData - The form data associated with the schema\n * @param options - The list of options that can be selected from\n * @param [selectedOption=-1] - The index of the currently selected option, defaulted to -1 if not specified\n * @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match\n */\nexport default function getClosestMatchingOption<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  rootSchema: S,\n  formData: T | undefined,\n  options: S[],\n  selectedOption = -1\n): number {\n  // Reduce the array of options down to a list of the indexes that are considered matching options\n  const allValidIndexes = options.reduce((validList: number[], option, index: number) => {\n    const testOptions: S[] = [JUNK_OPTION as S, option];\n    const match = getFirstMatchingOption<T, S, F>(validator, formData, testOptions, rootSchema);\n    // The match is the real option, so add its index to list of valid indexes\n    if (match === 1) {\n      validList.push(index);\n    }\n    return validList;\n  }, []);\n\n  // There is only one valid index, so return it!\n  if (allValidIndexes.length === 1) {\n    return allValidIndexes[0];\n  }\n  if (!allValidIndexes.length) {\n    // No indexes were valid, so we'll score all the options, add all the indexes\n    times(options.length, (i) => allValidIndexes.push(i));\n  }\n  type BestType = { bestIndex: number; bestScore: number };\n  // Score all the options in the list of valid indexes and return the index with the best score\n  const { bestIndex }: BestType = allValidIndexes.reduce(\n    (scoreData: BestType, index: number) => {\n      const { bestScore } = scoreData;\n      let option = options[index];\n      if (has(option, REF_KEY)) {\n        option = retrieveSchema<T, S, F>(validator, option, rootSchema, formData);\n      }\n      const score = calculateIndexScore(validator, rootSchema, option, formData);\n      if (score > bestScore) {\n        return { bestIndex: index, bestScore: score };\n      }\n      return scoreData;\n    },\n    { bestIndex: selectedOption, bestScore: 0 }\n  );\n  return bestIndex;\n}\n","import isObject from './isObject';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Detects whether the given `schema` contains fixed items. This is the case when `schema.items` is a non-empty array\n * that only contains objects.\n *\n * @param schema - The schema in which to check for fixed items\n * @returns - True if there are fixed items in the schema, false otherwise\n */\nexport default function isFixedItems<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  return Array.isArray(schema.items) && schema.items.length > 0 && schema.items.every((item) => isObject(item));\n}\n","import get from 'lodash/get';\n\nimport isObject from './isObject';\nimport { GenericObjectType } from '../src';\n\n/** Merges the `defaults` object of type `T` into the `formData` of type `T`\n *\n * When merging defaults and form data, we want to merge in this specific way:\n * - objects are deeply merged\n * - arrays are merged in such a way that:\n *   - when the array is set in form data, only array entries set in form data\n *     are deeply merged; additional entries from the defaults are ignored\n *   - when the array is not set in form data, the default is copied over\n * - scalars are overwritten/set by form data\n *\n * @param [defaults] - The defaults to merge\n * @param [formData] - The form data into which the defaults will be merged\n * @returns - The resulting merged form data with defaults\n */\nexport default function mergeDefaultsWithFormData<T = any>(defaults?: T, formData?: T): T | undefined {\n  if (Array.isArray(formData)) {\n    const defaultsArray = Array.isArray(defaults) ? defaults : [];\n    const mapped = formData.map((value, idx) => {\n      if (defaultsArray[idx]) {\n        return mergeDefaultsWithFormData<any>(defaultsArray[idx], value);\n      }\n      return value;\n    });\n    return mapped as unknown as T;\n  }\n  if (isObject(formData)) {\n    const acc: { [key in keyof T]: any } = Object.assign({}, defaults); // Prevent mutation of source object.\n    return Object.keys(formData as GenericObjectType).reduce((acc, key) => {\n      acc[key as keyof T] = mergeDefaultsWithFormData<T>(defaults ? get(defaults, key) : {}, get(formData, key));\n      return acc;\n    }, acc);\n  }\n  return formData;\n}\n","import isObject from './isObject';\nimport { GenericObjectType } from './types';\n\n/** Recursively merge deeply nested objects.\n *\n * @param obj1 - The first object to merge\n * @param obj2 - The second object to merge\n * @param [concatArrays=false] - Optional flag that, when true, will cause arrays to be concatenated. Use\n *          \"preventDuplicates\" to merge arrays in a manner that prevents any duplicate entries from being merged.\n *          NOTE: Uses shallow comparison for the duplicate checking.\n * @returns - A new object that is the merge of the two given objects\n */\nexport default function mergeObjects(\n  obj1: GenericObjectType,\n  obj2: GenericObjectType,\n  concatArrays: boolean | 'preventDuplicates' = false\n) {\n  return Object.keys(obj2).reduce((acc, key) => {\n    const left = obj1 ? obj1[key] : {},\n      right = obj2[key];\n    if (obj1 && key in obj1 && isObject(right)) {\n      acc[key] = mergeObjects(left, right, concatArrays);\n    } else if (concatArrays && Array.isArray(left) && Array.isArray(right)) {\n      let toMerge = right;\n      if (concatArrays === 'preventDuplicates') {\n        toMerge = right.reduce((result, value) => {\n          if (!left.includes(value)) {\n            result.push(value);\n          }\n          return result;\n        }, []);\n      }\n      acc[key] = left.concat(toMerge);\n    } else {\n      acc[key] = right;\n    }\n    return acc;\n  }, Object.assign({}, obj1)); // Prevent mutation of source object.\n}\n","import { CONST_KEY } from './constants';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** This function checks if the given `schema` matches a single constant value. This happens when either the schema has\n * an `enum` array with a single value or there is a `const` defined.\n *\n * @param schema - The schema for a field\n * @returns - True if the `schema` has a single constant value, false otherwise\n */\nexport default function isConstant<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  return (Array.isArray(schema.enum) && schema.enum.length === 1) || CONST_KEY in schema;\n}\n","import isConstant from '../isConstant';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport retrieveSchema from './retrieveSchema';\n\n/** Checks to see if the `schema` combination represents a select\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param theSchema - The schema for which check for a select flag is desired\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @returns - True if schema contains a select, otherwise false\n */\nexport default function isSelect<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  theSchema: S,\n  rootSchema: S = {} as S\n) {\n  const schema = retrieveSchema<T, S, F>(validator, theSchema, rootSchema, undefined);\n  const altSchemas = schema.oneOf || schema.anyOf;\n  if (Array.isArray(schema.enum)) {\n    return true;\n  }\n  if (Array.isArray(altSchemas)) {\n    return altSchemas.every((altSchemas) => typeof altSchemas !== 'boolean' && isConstant(altSchemas));\n  }\n  return false;\n}\n","import { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\n\nimport isSelect from './isSelect';\n\n/** Checks to see if the `schema` combination represents a multi-select\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which check for a multi-select flag is desired\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @returns - True if schema contains a multi-select, otherwise false\n */\nexport default function isMultiSelect<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, schema: S, rootSchema?: S) {\n  if (!schema.uniqueItems || !schema.items || typeof schema.items === 'boolean') {\n    return false;\n  }\n  return isSelect<T, S, F>(validator, schema.items as S, rootSchema);\n}\n","import get from 'lodash/get';\nimport isEmpty from 'lodash/isEmpty';\n\nimport { ANY_OF_KEY, DEFAULT_KEY, DEPENDENCIES_KEY, PROPERTIES_KEY, ONE_OF_KEY, REF_KEY } from '../constants';\nimport findSchemaDefinition from '../findSchemaDefinition';\nimport getClosestMatchingOption from './getClosestMatchingOption';\nimport getSchemaType from '../getSchemaType';\nimport isObject from '../isObject';\nimport isFixedItems from '../isFixedItems';\nimport mergeDefaultsWithFormData from '../mergeDefaultsWithFormData';\nimport mergeObjects from '../mergeObjects';\nimport { FormContextType, GenericObjectType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport isMultiSelect from './isMultiSelect';\nimport retrieveSchema, { resolveDependencies } from './retrieveSchema';\n\n/** Enum that indicates how `schema.additionalItems` should be handled by the `getInnerSchemaForArrayItem()` function.\n */\nexport enum AdditionalItemsHandling {\n  Ignore,\n  Invert,\n  Fallback,\n}\n\n/** Given a `schema` will return an inner schema that for an array item. This is computed differently based on the\n * `additionalItems` enum and the value of `idx`. There are four possible returns:\n * 1. If `idx` is >= 0, then if `schema.items` is an array the `idx`th element of the array is returned if it is a valid\n *    index and not a boolean, otherwise it falls through to 3.\n * 2. If `schema.items` is not an array AND truthy and not a boolean, then `schema.items` is returned since it actually\n *    is a schema, otherwise it falls through to 3.\n * 3. If `additionalItems` is not `AdditionalItemsHandling.Ignore` and `schema.additionalItems` is an object, then\n *    `schema.additionalItems` is returned since it actually is a schema, otherwise it falls through to 4.\n * 4. {} is returned representing an empty schema\n *\n * @param schema - The schema from which to get the particular item\n * @param [additionalItems=AdditionalItemsHandling.Ignore] - How do we want to handle additional items?\n * @param [idx=-1] - Index, if non-negative, will be used to return the idx-th element in a `schema.items` array\n * @returns - The best fit schema object from the `schema` given the `additionalItems` and `idx` modifiers\n */\nexport function getInnerSchemaForArrayItem<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S,\n  additionalItems: AdditionalItemsHandling = AdditionalItemsHandling.Ignore,\n  idx = -1\n): S {\n  if (idx >= 0) {\n    if (Array.isArray(schema.items) && idx < schema.items.length) {\n      const item = schema.items[idx];\n      if (typeof item !== 'boolean') {\n        return item as S;\n      }\n    }\n  } else if (schema.items && !Array.isArray(schema.items) && typeof schema.items !== 'boolean') {\n    return schema.items as S;\n  }\n  if (additionalItems !== AdditionalItemsHandling.Ignore && isObject(schema.additionalItems)) {\n    return schema.additionalItems as S;\n  }\n  return {} as S;\n}\n\n/** Either add `computedDefault` at `key` into `obj` or not add it based on its value and the value of\n * `includeUndefinedValues`. Generally undefined `computedDefault` values are added only when `includeUndefinedValues`\n * is either true or \"excludeObjectChildren\". If `includeUndefinedValues` is false, then non-undefined and\n * non-empty-object values will be added.\n *\n * @param obj - The object into which the computed default may be added\n * @param key - The key into the object at which the computed default may be added\n * @param computedDefault - The computed default value that maybe should be added to the obj\n * @param includeUndefinedValues - Optional flag, if true, cause undefined values to be added as defaults.\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties. If \"allowEmptyObject\", prevents undefined\n *          values in this object while allow the object itself to be empty and passing `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties.\n * @param requiredFields - The list of fields that are required\n */\nfunction maybeAddDefaultToObject<T = any>(\n  obj: GenericObjectType,\n  key: string,\n  computedDefault: T | T[] | undefined,\n  includeUndefinedValues: boolean | 'excludeObjectChildren',\n  requiredFields: string[] = []\n) {\n  if (includeUndefinedValues) {\n    obj[key] = computedDefault;\n  } else if (isObject(computedDefault)) {\n    // Store computedDefault if it's a non-empty object (e.g. not {})\n    if (!isEmpty(computedDefault) || requiredFields.includes(key)) {\n      obj[key] = computedDefault;\n    }\n  } else if (computedDefault !== undefined) {\n    // Store computedDefault if it's a defined primitive (e.g. true)\n    obj[key] = computedDefault;\n  }\n}\n\n/** Computes the defaults for the current `schema` given the `rawFormData` and `parentDefaults` if any. This drills into\n * each level of the schema, recursively, to fill out every level of defaults provided by the schema.\n *\n * @param validator - an implementation of the `ValidatorType` interface that will be used when necessary\n * @param rawSchema - The schema for which the default state is desired\n * @param [parentDefaults] - Any defaults provided by the parent field in the schema\n * @param [rootSchema] - The options root schema, used to primarily to look up `$ref`s\n * @param [rawFormData] - The current formData, if any, onto which to provide any missing defaults\n * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties.\n * @returns - The resulting `formData` with all the defaults provided\n */\nexport function computeDefaults<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  rawSchema: S,\n  parentDefaults?: T,\n  rootSchema: S = {} as S,\n  rawFormData?: T,\n  includeUndefinedValues: boolean | 'excludeObjectChildren' = false\n): T | T[] | undefined {\n  const formData: T = (isObject(rawFormData) ? rawFormData : {}) as T;\n  let schema: S = isObject(rawSchema) ? rawSchema : ({} as S);\n  // Compute the defaults recursively: give highest priority to deepest nodes.\n  let defaults: T | T[] | undefined = parentDefaults;\n  if (isObject(defaults) && isObject(schema.default)) {\n    // For object defaults, only override parent defaults that are defined in\n    // schema.default.\n    defaults = mergeObjects(defaults!, schema.default as GenericObjectType) as T;\n  } else if (DEFAULT_KEY in schema) {\n    defaults = schema.default as unknown as T;\n  } else if (REF_KEY in schema) {\n    // Use referenced schema defaults for this node.\n    const refSchema = findSchemaDefinition<S>(schema[REF_KEY]!, rootSchema);\n    return computeDefaults<T, S, F>(validator, refSchema, defaults, rootSchema, formData as T, includeUndefinedValues);\n  } else if (DEPENDENCIES_KEY in schema) {\n    const resolvedSchema = resolveDependencies<T, S, F>(validator, schema, rootSchema, formData);\n    return computeDefaults<T, S, F>(\n      validator,\n      resolvedSchema,\n      defaults,\n      rootSchema,\n      formData as T,\n      includeUndefinedValues\n    );\n  } else if (isFixedItems(schema)) {\n    defaults = (schema.items! as S[]).map((itemSchema: S, idx: number) =>\n      computeDefaults<T, S>(\n        validator,\n        itemSchema,\n        Array.isArray(parentDefaults) ? parentDefaults[idx] : undefined,\n        rootSchema,\n        formData as T,\n        includeUndefinedValues\n      )\n    ) as T[];\n  } else if (ONE_OF_KEY in schema) {\n    if (schema.oneOf!.length === 0) {\n      return undefined;\n    }\n    schema = schema.oneOf![\n      getClosestMatchingOption<T, S, F>(\n        validator,\n        rootSchema,\n        isEmpty(formData) ? undefined : formData,\n        schema.oneOf as S[],\n        0\n      )\n    ] as S;\n  } else if (ANY_OF_KEY in schema) {\n    if (schema.anyOf!.length === 0) {\n      return undefined;\n    }\n    schema = schema.anyOf![\n      getClosestMatchingOption<T, S, F>(\n        validator,\n        rootSchema,\n        isEmpty(formData) ? undefined : formData,\n        schema.anyOf as S[],\n        0\n      )\n    ] as S;\n  }\n\n  // Not defaults defined for this node, fallback to generic typed ones.\n  if (typeof defaults === 'undefined') {\n    defaults = schema.default as unknown as T;\n  }\n\n  switch (getSchemaType<S>(schema)) {\n    // We need to recur for object schema inner default values.\n    case 'object': {\n      const objectDefaults = Object.keys(schema.properties || {}).reduce((acc: GenericObjectType, key: string) => {\n        // Compute the defaults for this node, with the parent defaults we might\n        // have from a previous run: defaults[key].\n        const computedDefault = computeDefaults<T, S, F>(\n          validator,\n          get(schema, [PROPERTIES_KEY, key]),\n          get(defaults, [key]),\n          rootSchema,\n          get(formData, [key]),\n          includeUndefinedValues === true\n        );\n        maybeAddDefaultToObject<T>(acc, key, computedDefault, includeUndefinedValues, schema.required);\n        return acc;\n      }, {}) as T;\n      if (schema.additionalProperties && isObject(defaults)) {\n        const additionalPropertiesSchema = isObject(schema.additionalProperties) ? schema.additionalProperties : {}; // as per spec additionalProperties may be either schema or boolean\n        Object.keys(defaults as GenericObjectType)\n          .filter((key) => !schema.properties || !schema.properties[key])\n          .forEach((key) => {\n            const computedDefault = computeDefaults(\n              validator,\n              additionalPropertiesSchema as S,\n              get(defaults, [key]),\n              rootSchema,\n              get(formData, [key]),\n              includeUndefinedValues === true\n            );\n            maybeAddDefaultToObject<T>(\n              objectDefaults as GenericObjectType,\n              key,\n              computedDefault,\n              includeUndefinedValues\n            );\n          });\n      }\n      return objectDefaults;\n    }\n    case 'array':\n      // Inject defaults into existing array defaults\n      if (Array.isArray(defaults)) {\n        defaults = defaults.map((item, idx) => {\n          const schemaItem: S = getInnerSchemaForArrayItem<S>(schema, AdditionalItemsHandling.Fallback, idx);\n          return computeDefaults<T, S, F>(validator, schemaItem, item, rootSchema);\n        }) as T[];\n      }\n\n      // Deeply inject defaults into already existing form data\n      if (Array.isArray(rawFormData)) {\n        const schemaItem: S = getInnerSchemaForArrayItem<S>(schema);\n        defaults = rawFormData.map((item: T, idx: number) => {\n          return computeDefaults<T, S, F>(validator, schemaItem, get(defaults, [idx]), rootSchema, item);\n        }) as T[];\n      }\n      if (schema.minItems) {\n        if (!isMultiSelect<T, S, F>(validator, schema, rootSchema)) {\n          const defaultsLength = Array.isArray(defaults) ? defaults.length : 0;\n          if (schema.minItems > defaultsLength) {\n            const defaultEntries: T[] = (defaults || []) as T[];\n            // populate the array with the defaults\n            const fillerSchema: S = getInnerSchemaForArrayItem<S>(schema, AdditionalItemsHandling.Invert);\n            const fillerDefault = fillerSchema.default;\n            const fillerEntries: T[] = new Array(schema.minItems - defaultsLength).fill(\n              computeDefaults<any, S, F>(validator, fillerSchema, fillerDefault, rootSchema)\n            ) as T[];\n            // then fill up the rest with either the item default or empty, up to minItems\n            return defaultEntries.concat(fillerEntries);\n          }\n        }\n        return defaults ? defaults : [];\n      }\n  }\n  return defaults;\n}\n\n/** Returns the superset of `formData` that includes the given set updated to include any missing fields that have\n * computed to have defaults provided in the `schema`.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param theSchema - The schema for which the default state is desired\n * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties.\n * @returns - The resulting `formData` with all the defaults provided\n */\nexport default function getDefaultFormState<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  theSchema: S,\n  formData?: T,\n  rootSchema?: S,\n  includeUndefinedValues: boolean | 'excludeObjectChildren' = false\n) {\n  if (!isObject(theSchema)) {\n    throw new Error('Invalid schema: ' + theSchema);\n  }\n  const schema = retrieveSchema<T, S, F>(validator, theSchema, rootSchema, formData);\n  const defaults = computeDefaults<T, S, F>(validator, schema, undefined, rootSchema, formData, includeUndefinedValues);\n  if (typeof formData === 'undefined' || formData === null || (typeof formData === 'number' && isNaN(formData))) {\n    // No form data? Use schema defaults.\n    return defaults;\n  }\n  if (isObject(formData)) {\n    return mergeDefaultsWithFormData<T>(defaults as T, formData);\n  }\n  if (Array.isArray(formData)) {\n    return mergeDefaultsWithFormData<T[]>(defaults as T[], formData);\n  }\n  return formData;\n}\n","import getUiOptions from './getUiOptions';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema } from './types';\n\n/** Checks to see if the `uiSchema` contains the `widget` field and that the widget is not `hidden`\n *\n * @param uiSchema - The UI Schema from which to detect if it is customized\n * @returns - True if the `uiSchema` describes a custom widget, false otherwise\n */\nexport default function isCustomWidget<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(uiSchema: UiSchema<T, S, F> = {}) {\n  return (\n    // TODO: Remove the `&& uiSchema['ui:widget'] !== 'hidden'` once we support hidden widgets for arrays.\n    // https://rjsf-team.github.io/react-jsonschema-form/docs/usage/widgets/#hidden-widgets\n    'widget' in getUiOptions<T, S, F>(uiSchema) && getUiOptions<T, S, F>(uiSchema)['widget'] !== 'hidden'\n  );\n}\n","import { UI_WIDGET_KEY } from '../constants';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema, ValidatorType } from '../types';\nimport retrieveSchema from './retrieveSchema';\n\n/** Checks to see if the `schema` and `uiSchema` combination represents an array of files\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which check for array of files flag is desired\n * @param [uiSchema={}] - The UI schema from which to check the widget\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @returns - True if schema/uiSchema contains an array of files, otherwise false\n */\nexport default function isFilesArray<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  uiSchema: UiSchema<T, S, F> = {},\n  rootSchema?: S\n) {\n  if (uiSchema[UI_WIDGET_KEY] === 'files') {\n    return true;\n  }\n  if (schema.items) {\n    const itemsSchema = retrieveSchema<T, S, F>(validator, schema.items as S, rootSchema);\n    return itemsSchema.type === 'string' && itemsSchema.format === 'data-url';\n  }\n  return false;\n}\n","import { UI_FIELD_KEY, UI_WIDGET_KEY } from '../constants';\nimport getSchemaType from '../getSchemaType';\nimport getUiOptions from '../getUiOptions';\nimport isCustomWidget from '../isCustomWidget';\nimport {\n  FormContextType,\n  GlobalUISchemaOptions,\n  RJSFSchema,\n  StrictRJSFSchema,\n  UiSchema,\n  ValidatorType,\n} from '../types';\nimport isFilesArray from './isFilesArray';\nimport isMultiSelect from './isMultiSelect';\n\n/** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`\n * should be displayed in a UI.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the display label flag is desired\n * @param [uiSchema={}] - The UI schema from which to derive potentially displayable information\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options\n * @returns - True if the label should be displayed or false if it should not\n */\nexport default function getDisplayLabel<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  uiSchema: UiSchema<T, S, F> = {},\n  rootSchema?: S,\n  globalOptions?: GlobalUISchemaOptions\n): boolean {\n  const uiOptions = getUiOptions<T, S, F>(uiSchema, globalOptions);\n  const { label = true } = uiOptions;\n  let displayLabel = !!label;\n  const schemaType = getSchemaType<S>(schema);\n\n  if (schemaType === 'array') {\n    displayLabel =\n      isMultiSelect<T, S, F>(validator, schema, rootSchema) ||\n      isFilesArray<T, S, F>(validator, schema, uiSchema, rootSchema) ||\n      isCustomWidget(uiSchema);\n  }\n\n  if (schemaType === 'object') {\n    displayLabel = false;\n  }\n  if (schemaType === 'boolean' && !uiSchema[UI_WIDGET_KEY]) {\n    displayLabel = false;\n  }\n  if (uiSchema[UI_FIELD_KEY]) {\n    displayLabel = false;\n  }\n  return displayLabel;\n}\n","import isEmpty from 'lodash/isEmpty';\n\nimport mergeObjects from '../mergeObjects';\nimport { ErrorSchema, FormContextType, RJSFSchema, StrictRJSFSchema, ValidationData, ValidatorType } from '../types';\n\n/** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in the\n * two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\n * `validator.toErrorList()` onto the `errors` in the `validationData`. If no `additionalErrorSchema` is passed, then\n * `validationData` is returned.\n *\n * @param validator - The validator used to convert an ErrorSchema to a list of errors\n * @param validationData - The current `ValidationData` into which to merge the additional errors\n * @param [additionalErrorSchema] - The additional set of errors in an `ErrorSchema`\n * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\n */\nexport default function mergeValidationData<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  validationData: ValidationData<T>,\n  additionalErrorSchema?: ErrorSchema<T>\n): ValidationData<T> {\n  if (!additionalErrorSchema) {\n    return validationData;\n  }\n  const { errors: oldErrors, errorSchema: oldErrorSchema } = validationData;\n  let errors = validator.toErrorList(additionalErrorSchema);\n  let errorSchema = additionalErrorSchema;\n  if (!isEmpty(oldErrorSchema)) {\n    errorSchema = mergeObjects(oldErrorSchema, additionalErrorSchema, true) as ErrorSchema<T>;\n    errors = [...oldErrors].concat(errors);\n  }\n  return { errorSchema, errors };\n}\n","import get from 'lodash/get';\nimport has from 'lodash/has';\n\nimport { FormContextType, GenericObjectType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport { PROPERTIES_KEY, REF_KEY } from '../constants';\nimport retrieveSchema from './retrieveSchema';\n\nconst NO_VALUE = Symbol('no Value');\n\n/** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the new\n * schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the nature\n * of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the old schema\n * that are non-existent in the new schema are set to `undefined`. The data sanitization process has the following flow:\n *\n * - If the new schema is an object that contains a `properties` object then:\n *   - Create a `removeOldSchemaData` object, setting each key in the `oldSchema.properties` having `data` to undefined\n *   - Create an empty `nestedData` object for use in the key filtering below:\n *   - Iterate over each key in the `newSchema.properties` as follows:\n *     - Get the `formValue` of the key from the `data`\n *     - Get the `oldKeySchema` and `newKeyedSchema` for the key, defaulting to `{}` when it doesn't exist\n *     - Retrieve the schema for any refs within each `oldKeySchema` and/or `newKeySchema`\n *     - Get the types of the old and new keyed schemas and if the old doesn't exist or the old & new are the same then:\n *       - If `removeOldSchemaData` has an entry for the key, delete it since the new schema has the same property\n *       - If type of the key in the new schema is `object`:\n *         - Store the value from the recursive `sanitizeDataForNewSchema` call in `nestedData[key]`\n *       - Otherwise, check for default or const values:\n *         - Get the old and new `default` values from the schema and check:\n *           - If the new `default` value does not match the form value:\n *             - If the old `default` value DOES match the form value, then:\n *               - Replace `removeOldSchemaData[key]` with the new `default`\n *               - Otherwise, if the new schema is `readOnly` then replace `removeOldSchemaData[key]` with undefined\n *         - Get the old and new `const` values from the schema and check:\n *           - If the new `const` value does not match the form value:\n *           - If the old `const` value DOES match the form value, then:\n *             - Replace `removeOldSchemaData[key]` with the new `const`\n *             - Otherwise, replace `removeOldSchemaData[key]` with undefined\n *   - Once all keys have been processed, return an object built as follows:\n *     - `{ ...removeOldSchemaData, ...nestedData, ...pick(data, keysToKeep) }`\n * - If the new and old schema types are array and the `data` is an array then:\n *   - If the type of the old and new schema `items` are a non-array objects:\n *     - Retrieve the schema for any refs within each `oldKeySchema.items` and/or `newKeySchema.items`\n *     - If the `type`s of both items are the same (or the old does not have a type):\n *       - If the type is \"object\", then:\n *         - For each element in the `data` recursively sanitize the data, stopping at `maxItems` if specified\n *       - Otherwise, just return the `data` removing any values after `maxItems` if it is set\n *   - If the type of the old and new schema `items` are booleans of the same value, return `data` as is\n * - Otherwise return `undefined`\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param rootSchema - The root JSON schema of the entire form\n * @param [newSchema] - The new schema for which the data is being sanitized\n * @param [oldSchema] - The old schema from which the data originated\n * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined\n * @returns - The new form data, with all the fields uniquely associated with the old schema set\n *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.\n */\nexport default function sanitizeDataForNewSchema<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, rootSchema: S, newSchema?: S, oldSchema?: S, data: any = {}): T {\n  // By default, we will clear the form data\n  let newFormData;\n  // If the new schema is of type object and that object contains a list of properties\n  if (has(newSchema, PROPERTIES_KEY)) {\n    // Create an object containing root-level keys in the old schema, setting each key to undefined to remove the data\n    const removeOldSchemaData: GenericObjectType = {};\n    if (has(oldSchema, PROPERTIES_KEY)) {\n      const properties = get(oldSchema, PROPERTIES_KEY, {});\n      Object.keys(properties).forEach((key) => {\n        if (has(data, key)) {\n          removeOldSchemaData[key] = undefined;\n        }\n      });\n    }\n    const keys: string[] = Object.keys(get(newSchema, PROPERTIES_KEY, {}));\n    // Create a place to store nested data that will be a side-effect of the filter\n    const nestedData: GenericObjectType = {};\n    keys.forEach((key) => {\n      const formValue = get(data, key);\n      let oldKeyedSchema: S = get(oldSchema, [PROPERTIES_KEY, key], {});\n      let newKeyedSchema: S = get(newSchema, [PROPERTIES_KEY, key], {});\n      // Resolve the refs if they exist\n      if (has(oldKeyedSchema, REF_KEY)) {\n        oldKeyedSchema = retrieveSchema<T, S, F>(validator, oldKeyedSchema, rootSchema, formValue);\n      }\n      if (has(newKeyedSchema, REF_KEY)) {\n        newKeyedSchema = retrieveSchema<T, S, F>(validator, newKeyedSchema, rootSchema, formValue);\n      }\n      // Now get types and see if they are the same\n      const oldSchemaTypeForKey = get(oldKeyedSchema, 'type');\n      const newSchemaTypeForKey = get(newKeyedSchema, 'type');\n      // Check if the old option has the same key with the same type\n      if (!oldSchemaTypeForKey || oldSchemaTypeForKey === newSchemaTypeForKey) {\n        if (has(removeOldSchemaData, key)) {\n          // SIDE-EFFECT: remove the undefined value for a key that has the same type between the old and new schemas\n          delete removeOldSchemaData[key];\n        }\n        // If it is an object, we'll recurse and store the resulting sanitized data for the key\n        if (newSchemaTypeForKey === 'object' || (newSchemaTypeForKey === 'array' && Array.isArray(formValue))) {\n          // SIDE-EFFECT: process the new schema type of object recursively to save iterations\n          const itemData = sanitizeDataForNewSchema<T, S, F>(\n            validator,\n            rootSchema,\n            newKeyedSchema,\n            oldKeyedSchema,\n            formValue\n          );\n          if (itemData !== undefined || newSchemaTypeForKey === 'array') {\n            // only put undefined values for the array type and not the object type\n            nestedData[key] = itemData;\n          }\n        } else {\n          // Ok, the non-object types match, let's make sure that a default or a const of a different value is replaced\n          // with the new default or const. This allows the case where two schemas differ that only by the default/const\n          // value to be properly selected\n          const newOptionDefault = get(newKeyedSchema, 'default', NO_VALUE);\n          const oldOptionDefault = get(oldKeyedSchema, 'default', NO_VALUE);\n          if (newOptionDefault !== NO_VALUE && newOptionDefault !== formValue) {\n            if (oldOptionDefault === formValue) {\n              // If the old default matches the formValue, we'll update the new value to match the new default\n              removeOldSchemaData[key] = newOptionDefault;\n            } else if (get(newKeyedSchema, 'readOnly') === true) {\n              // If the new schema has the default set to read-only, treat it like a const and remove the value\n              removeOldSchemaData[key] = undefined;\n            }\n          }\n\n          const newOptionConst = get(newKeyedSchema, 'const', NO_VALUE);\n          const oldOptionConst = get(oldKeyedSchema, 'const', NO_VALUE);\n          if (newOptionConst !== NO_VALUE && newOptionConst !== formValue) {\n            // Since this is a const, if the old value matches, replace the value with the new const otherwise clear it\n            removeOldSchemaData[key] = oldOptionConst === formValue ? newOptionConst : undefined;\n          }\n        }\n      }\n    });\n\n    newFormData = {\n      ...data,\n      ...removeOldSchemaData,\n      ...nestedData,\n    };\n    // First apply removing the old schema data, then apply the nested data, then apply the old data keys to keep\n  } else if (get(oldSchema, 'type') === 'array' && get(newSchema, 'type') === 'array' && Array.isArray(data)) {\n    let oldSchemaItems = get(oldSchema, 'items');\n    let newSchemaItems = get(newSchema, 'items');\n    // If any of the array types `items` are arrays (remember arrays are objects) then we'll just drop the data\n    // Eventually, we may want to deal with when either of the `items` are arrays since those tuple validations\n    if (\n      typeof oldSchemaItems === 'object' &&\n      typeof newSchemaItems === 'object' &&\n      !Array.isArray(oldSchemaItems) &&\n      !Array.isArray(newSchemaItems)\n    ) {\n      if (has(oldSchemaItems, REF_KEY)) {\n        oldSchemaItems = retrieveSchema<T, S, F>(validator, oldSchemaItems as S, rootSchema, data as T);\n      }\n      if (has(newSchemaItems, REF_KEY)) {\n        newSchemaItems = retrieveSchema<T, S, F>(validator, newSchemaItems as S, rootSchema, data as T);\n      }\n      // Now get types and see if they are the same\n      const oldSchemaType = get(oldSchemaItems, 'type');\n      const newSchemaType = get(newSchemaItems, 'type');\n      // Check if the old option has the same key with the same type\n      if (!oldSchemaType || oldSchemaType === newSchemaType) {\n        const maxItems = get(newSchema, 'maxItems', -1);\n        if (newSchemaType === 'object') {\n          newFormData = data.reduce((newValue, aValue) => {\n            const itemValue = sanitizeDataForNewSchema<T, S, F>(\n              validator,\n              rootSchema,\n              newSchemaItems as S,\n              oldSchemaItems as S,\n              aValue\n            );\n            if (itemValue !== undefined && (maxItems < 0 || newValue.length < maxItems)) {\n              newValue.push(itemValue);\n            }\n            return newValue;\n          }, []);\n        } else {\n          newFormData = maxItems > 0 && data.length > maxItems ? data.slice(0, maxItems) : data;\n        }\n      }\n    } else if (\n      typeof oldSchemaItems === 'boolean' &&\n      typeof newSchemaItems === 'boolean' &&\n      oldSchemaItems === newSchemaItems\n    ) {\n      // If they are both booleans and have the same value just return the data as is otherwise fall-thru to undefined\n      newFormData = data;\n    }\n    // Also probably want to deal with `prefixItems` as tuples with the latest 2020 draft\n  }\n  return newFormData as T;\n}\n","import get from 'lodash/get';\n\nimport { ALL_OF_KEY, DEPENDENCIES_KEY, ID_KEY, ITEMS_KEY, PROPERTIES_KEY, REF_KEY } from '../constants';\nimport isObject from '../isObject';\nimport { FormContextType, IdSchema, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport retrieveSchema from './retrieveSchema';\n\n/** Generates an `IdSchema` object for the `schema`, recursively\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the `IdSchema` is desired\n * @param [id] - The base id for the schema\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @param [idPrefix='root'] - The prefix to use for the id\n * @param [idSeparator='_'] - The separator to use for the path segments in the id\n * @returns - The `IdSchema` object for the `schema`\n */\nexport default function toIdSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  id?: string | null,\n  rootSchema?: S,\n  formData?: T,\n  idPrefix = 'root',\n  idSeparator = '_'\n): IdSchema<T> {\n  if (REF_KEY in schema || DEPENDENCIES_KEY in schema || ALL_OF_KEY in schema) {\n    const _schema = retrieveSchema<T, S, F>(validator, schema, rootSchema, formData);\n    return toIdSchema<T, S, F>(validator, _schema, id, rootSchema, formData, idPrefix, idSeparator);\n  }\n  if (ITEMS_KEY in schema && !get(schema, [ITEMS_KEY, REF_KEY])) {\n    return toIdSchema<T, S, F>(validator, get(schema, ITEMS_KEY) as S, id, rootSchema, formData, idPrefix, idSeparator);\n  }\n  const $id = id || idPrefix;\n  const idSchema: IdSchema = { $id } as IdSchema<T>;\n  if (schema.type === 'object' && PROPERTIES_KEY in schema) {\n    for (const name in schema.properties) {\n      const field = get(schema, [PROPERTIES_KEY, name]);\n      const fieldId = idSchema[ID_KEY] + idSeparator + name;\n      idSchema[name] = toIdSchema<T, S, F>(\n        validator,\n        isObject(field) ? field : {},\n        fieldId,\n        rootSchema,\n        // It's possible that formData is not an object -- this can happen if an\n        // array item has just been added, but not populated with data yet\n        get(formData, [name]),\n        idPrefix,\n        idSeparator\n      );\n    }\n  }\n  return idSchema as IdSchema<T>;\n}\n","import get from 'lodash/get';\nimport set from 'lodash/set';\n\nimport {\n  ALL_OF_KEY,\n  ANY_OF_KEY,\n  ADDITIONAL_PROPERTIES_KEY,\n  DEPENDENCIES_KEY,\n  ITEMS_KEY,\n  NAME_KEY,\n  ONE_OF_KEY,\n  PROPERTIES_KEY,\n  REF_KEY,\n  RJSF_ADDITONAL_PROPERTIES_FLAG,\n} from '../constants';\nimport { FormContextType, PathSchema, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport { getClosestMatchingOption } from './index';\nimport retrieveSchema from './retrieveSchema';\n\n/** Generates an `PathSchema` object for the `schema`, recursively\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the `PathSchema` is desired\n * @param [name=''] - The base name for the schema\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The `PathSchema` object for the `schema`\n */\nexport default function toPathSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  name = '',\n  rootSchema?: S,\n  formData?: T\n): PathSchema<T> {\n  if (REF_KEY in schema || DEPENDENCIES_KEY in schema || ALL_OF_KEY in schema) {\n    const _schema = retrieveSchema<T, S, F>(validator, schema, rootSchema, formData);\n    return toPathSchema<T, S, F>(validator, _schema, name, rootSchema, formData);\n  }\n\n  const pathSchema: PathSchema = {\n    [NAME_KEY]: name.replace(/^\\./, ''),\n  } as PathSchema;\n\n  if (ONE_OF_KEY in schema) {\n    const index = getClosestMatchingOption<T, S, F>(validator, rootSchema!, formData, schema.oneOf as S[], 0);\n    const _schema: S = schema.oneOf![index] as S;\n    return toPathSchema<T, S, F>(validator, _schema, name, rootSchema, formData);\n  }\n\n  if (ANY_OF_KEY in schema) {\n    const index = getClosestMatchingOption<T, S, F>(validator, rootSchema!, formData, schema.anyOf as S[], 0);\n    const _schema: S = schema.anyOf![index] as S;\n    return toPathSchema<T, S, F>(validator, _schema, name, rootSchema, formData);\n  }\n\n  if (ADDITIONAL_PROPERTIES_KEY in schema && schema[ADDITIONAL_PROPERTIES_KEY] !== false) {\n    set(pathSchema, RJSF_ADDITONAL_PROPERTIES_FLAG, true);\n  }\n\n  if (ITEMS_KEY in schema && Array.isArray(formData)) {\n    formData.forEach((element, i: number) => {\n      pathSchema[i] = toPathSchema<T, S, F>(validator, schema.items as S, `${name}.${i}`, rootSchema, element);\n    });\n  } else if (PROPERTIES_KEY in schema) {\n    for (const property in schema.properties) {\n      const field = get(schema, [PROPERTIES_KEY, property]);\n      pathSchema[property] = toPathSchema<T, S, F>(\n        validator,\n        field,\n        `${name}.${property}`,\n        rootSchema,\n        // It's possible that formData is not an object -- this can happen if an\n        // array item has just been added, but not populated with data yet\n        get(formData, [property])\n      );\n    }\n  }\n  return pathSchema as PathSchema<T>;\n}\n","import deepEquals from './deepEquals';\nimport {\n  ErrorSchema,\n  FormContextType,\n  GlobalUISchemaOptions,\n  IdSchema,\n  PathSchema,\n  RJSFSchema,\n  SchemaUtilsType,\n  StrictRJSFSchema,\n  UiSchema,\n  ValidationData,\n  ValidatorType,\n} from './types';\nimport {\n  getDefaultFormState,\n  getDisplayLabel,\n  getClosestMatchingOption,\n  getFirstMatchingOption,\n  getMatchingOption,\n  isFilesArray,\n  isMultiSelect,\n  isSelect,\n  mergeValidationData,\n  retrieveSchema,\n  sanitizeDataForNewSchema,\n  toIdSchema,\n  toPathSchema,\n} from './schema';\n\n/** The `SchemaUtils` class provides a wrapper around the publicly exported APIs in the `utils/schema` directory such\n * that one does not have to explicitly pass the `validator` or `rootSchema` to each method. Since both the `validator`\n * and `rootSchema` generally does not change across a `Form`, this allows for providing a simplified set of APIs to the\n * `@rjsf/core` components and the various themes as well. This class implements the `SchemaUtilsType` interface.\n */\nclass SchemaUtils<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>\n  implements SchemaUtilsType<T, S, F>\n{\n  rootSchema: S;\n  validator: ValidatorType<T, S, F>;\n\n  /** Constructs the `SchemaUtils` instance with the given `validator` and `rootSchema` stored as instance variables\n   *\n   * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n   * @param rootSchema - The root schema that will be forwarded to all the APIs\n   */\n  constructor(validator: ValidatorType<T, S, F>, rootSchema: S) {\n    this.rootSchema = rootSchema;\n    this.validator = validator;\n  }\n\n  /** Returns the `ValidatorType` in the `SchemaUtilsType`\n   *\n   * @returns - The `ValidatorType`\n   */\n  getValidator() {\n    return this.validator;\n  }\n\n  /** Determines whether either the `validator` and `rootSchema` differ from the ones associated with this instance of\n   * the `SchemaUtilsType`. If either `validator` or `rootSchema` are falsy, then return false to prevent the creation\n   * of a new `SchemaUtilsType` with incomplete properties.\n   *\n   * @param validator - An implementation of the `ValidatorType` interface that will be compared against the current one\n   * @param rootSchema - The root schema that will be compared against the current one\n   * @returns - True if the `SchemaUtilsType` differs from the given `validator` or `rootSchema`\n   */\n  doesSchemaUtilsDiffer(validator: ValidatorType<T, S, F>, rootSchema: S): boolean {\n    if (!validator || !rootSchema) {\n      return false;\n    }\n    return this.validator !== validator || !deepEquals(this.rootSchema, rootSchema);\n  }\n\n  /** Returns the superset of `formData` that includes the given set updated to include any missing fields that have\n   * computed to have defaults provided in the `schema`.\n   *\n   * @param schema - The schema for which the default state is desired\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n   * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\n   *          If \"excludeObjectChildren\", pass `includeUndefinedValues` as false when computing defaults for any nested\n   *          object properties.\n   * @returns - The resulting `formData` with all the defaults provided\n   */\n  getDefaultFormState(\n    schema: S,\n    formData?: T,\n    includeUndefinedValues: boolean | 'excludeObjectChildren' = false\n  ): T | T[] | undefined {\n    return getDefaultFormState<T, S, F>(this.validator, schema, formData, this.rootSchema, includeUndefinedValues);\n  }\n\n  /** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`\n   * should be displayed in a UI.\n   *\n   * @param schema - The schema for which the display label flag is desired\n   * @param [uiSchema] - The UI schema from which to derive potentially displayable information\n   * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options\n   * @returns - True if the label should be displayed or false if it should not\n   */\n  getDisplayLabel(schema: S, uiSchema?: UiSchema<T, S, F>, globalOptions?: GlobalUISchemaOptions) {\n    return getDisplayLabel<T, S, F>(this.validator, schema, uiSchema, this.rootSchema, globalOptions);\n  }\n\n  /** Determines which of the given `options` provided most closely matches the `formData`.\n   * Returns the index of the option that is valid and is the closest match, or 0 if there is no match.\n   *\n   * The closest match is determined using the number of matching properties, and more heavily favors options with\n   * matching readOnly, default, or const values.\n   *\n   * @param formData - The form data associated with the schema\n   * @param options - The list of options that can be selected from\n   * @param [selectedOption] - The index of the currently selected option, defaulted to -1 if not specified\n   * @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match\n   */\n  getClosestMatchingOption(formData: T | undefined, options: S[], selectedOption?: number): number {\n    return getClosestMatchingOption<T, S, F>(this.validator, this.rootSchema, formData, options, selectedOption);\n  }\n\n  /** Given the `formData` and list of `options`, attempts to find the index of the first option that matches the data.\n   * Always returns the first option if there is nothing that matches.\n   *\n   * @param formData - The current formData, if any, used to figure out a match\n   * @param options - The list of options to find a matching options from\n   * @returns - The firstindex of the matched option or 0 if none is available\n   */\n  getFirstMatchingOption(formData: T | undefined, options: S[]): number {\n    return getFirstMatchingOption<T, S, F>(this.validator, formData, options, this.rootSchema);\n  }\n\n  /** Given the `formData` and list of `options`, attempts to find the index of the option that best matches the data.\n   * Deprecated, use `getFirstMatchingOption()` instead.\n   *\n   * @param formData - The current formData, if any, onto which to provide any missing defaults\n   * @param options - The list of options to find a matching options from\n   * @returns - The index of the matched option or 0 if none is available\n   * @deprecated\n   */\n  getMatchingOption(formData: T | undefined, options: S[]) {\n    return getMatchingOption<T, S, F>(this.validator, formData, options, this.rootSchema);\n  }\n\n  /** Checks to see if the `schema` and `uiSchema` combination represents an array of files\n   *\n   * @param schema - The schema for which check for array of files flag is desired\n   * @param [uiSchema] - The UI schema from which to check the widget\n   * @returns - True if schema/uiSchema contains an array of files, otherwise false\n   */\n  isFilesArray(schema: S, uiSchema?: UiSchema<T, S, F>) {\n    return isFilesArray<T, S, F>(this.validator, schema, uiSchema, this.rootSchema);\n  }\n\n  /** Checks to see if the `schema` combination represents a multi-select\n   *\n   * @param schema - The schema for which check for a multi-select flag is desired\n   * @returns - True if schema contains a multi-select, otherwise false\n   */\n  isMultiSelect(schema: S) {\n    return isMultiSelect<T, S, F>(this.validator, schema, this.rootSchema);\n  }\n\n  /** Checks to see if the `schema` combination represents a select\n   *\n   * @param schema - The schema for which check for a select flag is desired\n   * @returns - True if schema contains a select, otherwise false\n   */\n  isSelect(schema: S) {\n    return isSelect<T, S, F>(this.validator, schema, this.rootSchema);\n  }\n\n  /** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in\n   * the two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\n   * `getValidator().toErrorList()` onto the `errors` in the `validationData`. If no `additionalErrorSchema` is passed,\n   * then `validationData` is returned.\n   *\n   * @param validationData - The current `ValidationData` into which to merge the additional errors\n   * @param [additionalErrorSchema] - The additional set of errors\n   * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\n   */\n  mergeValidationData(validationData: ValidationData<T>, additionalErrorSchema?: ErrorSchema<T>): ValidationData<T> {\n    return mergeValidationData<T, S, F>(this.validator, validationData, additionalErrorSchema);\n  }\n\n  /** Retrieves an expanded schema that has had all of its conditions, additional properties, references and\n   * dependencies resolved and merged into the `schema` given a `rawFormData` that is used to do the potentially\n   * recursive resolution.\n   *\n   * @param schema - The schema for which retrieving a schema is desired\n   * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\n   * @returns - The schema having its conditions, additional properties, references and dependencies resolved\n   */\n  retrieveSchema(schema: S, rawFormData?: T) {\n    return retrieveSchema<T, S, F>(this.validator, schema, this.rootSchema, rawFormData);\n  }\n\n  /** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the\n   * new schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the\n   * nature of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the\n   * old schemas that are non-existent in the new schema are set to `undefined`.\n   *\n   * @param [newSchema] - The new schema for which the data is being sanitized\n   * @param [oldSchema] - The old schema from which the data originated\n   * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined\n   * @returns - The new form data, with all the fields uniquely associated with the old schema set\n   *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.\n   */\n  sanitizeDataForNewSchema(newSchema?: S, oldSchema?: S, data?: any): T {\n    return sanitizeDataForNewSchema(this.validator, this.rootSchema, newSchema, oldSchema, data);\n  }\n\n  /** Generates an `IdSchema` object for the `schema`, recursively\n   *\n   * @param schema - The schema for which the display label flag is desired\n   * @param [id] - The base id for the schema\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n   * @param [idPrefix='root'] - The prefix to use for the id\n   * @param [idSeparator='_'] - The separator to use for the path segments in the id\n   * @returns - The `IdSchema` object for the `schema`\n   */\n  toIdSchema(schema: S, id?: string | null, formData?: T, idPrefix = 'root', idSeparator = '_'): IdSchema<T> {\n    return toIdSchema<T, S, F>(this.validator, schema, id, this.rootSchema, formData, idPrefix, idSeparator);\n  }\n\n  /** Generates an `PathSchema` object for the `schema`, recursively\n   *\n   * @param schema - The schema for which the display label flag is desired\n   * @param [name] - The base name for the schema\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n   * @returns - The `PathSchema` object for the `schema`\n   */\n  toPathSchema(schema: S, name?: string, formData?: T): PathSchema<T> {\n    return toPathSchema<T, S, F>(this.validator, schema, name, this.rootSchema, formData);\n  }\n}\n\n/** Creates a `SchemaUtilsType` interface that is based around the given `validator` and `rootSchema` parameters. The\n * resulting interface implementation will forward the `validator` and `rootSchema` to all the wrapped APIs.\n *\n * @param validator - an implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @returns - An implementation of a `SchemaUtilsType` interface\n */\nexport default function createSchemaUtils<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, rootSchema: S): SchemaUtilsType<T, S, F> {\n  return new SchemaUtils<T, S, F>(validator, rootSchema);\n}\n","/** Given the `FileReader.readAsDataURL()` based `dataURI` extracts that data into an actual Blob along with the name\n * of that Blob if provided in the URL. If no name is provided, then the name falls back to `unknown`.\n *\n * @param dataURI - The `DataUrl` potentially containing name and raw data to be converted to a Blob\n * @returns - an object containing a Blob and its name, extracted from the URI\n */\nexport default function dataURItoBlob(dataURI: string) {\n  // Split metadata from data\n  const splitted: string[] = dataURI.split(',');\n  // Split params\n  const params: string[] = splitted[0].split(';');\n  // Get mime-type from params\n  const type: string = params[0].replace('data:', '');\n  // Filter the name property from params\n  const properties = params.filter((param) => {\n    return param.split('=')[0] === 'name';\n  });\n  // Look for the name and use unknown if no name property.\n  let name: string;\n  if (properties.length !== 1) {\n    name = 'unknown';\n  } else {\n    // Because we filtered out the other property,\n    // we only have the name case here, which we decode to make it human-readable\n    name = decodeURI(properties[0].split('=')[1]);\n  }\n\n  // Built the Uint8Array Blob parameter from the base64 string.\n  try {\n    const binary = atob(splitted[1]);\n    const array = [];\n    for (let i = 0; i < binary.length; i++) {\n      array.push(binary.charCodeAt(i));\n    }\n    // Create the blob object\n    const blob = new window.Blob([new Uint8Array(array)], { type });\n\n    return { blob, name };\n  } catch (error) {\n    return { blob: { size: 0, type: (error as Error).message }, name: dataURI };\n  }\n}\n","/** Potentially substitutes all replaceable parameters with the associated value(s) from the `params` if available. When\n * a `params` array is provided, each value in the array is used to replace any of the replaceable parameters in the\n * `inputString` using the `%1`, `%2`, etc. replacement specifiers.\n *\n * @param inputString - The string which will be potentially updated with replacement parameters\n * @param params - The optional list of replaceable parameter values to substitute into the english string\n * @returns - The updated string with any replacement specifiers replaced\n */\nexport default function replaceStringParameters(inputString: string, params?: string[]) {\n  let output = inputString;\n  if (Array.isArray(params)) {\n    const parts = output.split(/(%\\d)/);\n    params.forEach((param, index) => {\n      const partIndex = parts.findIndex((part) => part === `%${index + 1}`);\n      if (partIndex >= 0) {\n        parts[partIndex] = param;\n      }\n    });\n    output = parts.join('');\n  }\n  return output;\n}\n","import { TranslatableString } from './enums';\nimport replaceStringParameters from './replaceStringParameters';\n\n/** Translates a `TranslatableString` value `stringToTranslate` into english. When a `params` array is provided, each\n * value in the array is used to replace any of the replaceable parameters in the `stringToTranslate` using the `%1`,\n * `%2`, etc. replacement specifiers.\n *\n * @param stringToTranslate - The `TranslatableString` value to convert to english\n * @param params - The optional list of replaceable parameter values to substitute into the english string\n * @returns - The `stringToTranslate` itself with any replaceable parameter values substituted\n */\nexport default function englishStringTranslator(stringToTranslate: TranslatableString, params?: string[]): string {\n  return replaceStringParameters(stringToTranslate, params);\n}\n","import { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Returns the value(s) from `allEnumOptions` at the index(es) provided by `valueIndex`. If `valueIndex` is not an\n * array AND the index is not valid for `allEnumOptions`, `emptyValue` is returned. If `valueIndex` is an array, AND it\n * contains an invalid index, the returned array will have the resulting undefined values filtered out, leaving only\n * valid values or in the worst case, an empty array.\n *\n * @param valueIndex - The index(es) of the value(s) that should be returned\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\n * @param [emptyValue] - The value to return when the non-array `valueIndex` does not refer to a real option\n * @returns - The single or list of values specified by the single or list of indexes if they are valid. Otherwise,\n *        `emptyValue` or an empty list.\n */\nexport default function enumOptionsValueForIndex<S extends StrictRJSFSchema = RJSFSchema>(\n  valueIndex: string | number | Array<string | number>,\n  allEnumOptions: EnumOptionsType<S>[] = [],\n  emptyValue?: EnumOptionsType<S>['value']\n): EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][] | undefined {\n  if (Array.isArray(valueIndex)) {\n    return valueIndex.map((index) => enumOptionsValueForIndex(index, allEnumOptions)).filter((val) => val);\n  }\n  // So Number(null) and Number('') both return 0, so use emptyValue for those two values\n  const index = valueIndex === '' || valueIndex === null ? -1 : Number(valueIndex);\n  const option = allEnumOptions[index];\n  return option ? option.value : emptyValue;\n}\n","import isEqual from 'lodash/isEqual';\n\nimport { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\nimport enumOptionsValueForIndex from './enumOptionsValueForIndex';\n\n/** Removes the enum option value at the `valueIndex` from the currently `selected` (list of) value(s). If `selected` is\n * a list, then that list is updated to remove the enum option value with the `valueIndex` in `allEnumOptions`. If it is\n * a single value, then if the enum option value with the `valueIndex` in `allEnumOptions` matches `selected`, undefined\n * is returned, otherwise the `selected` value is returned.\n *\n * @param valueIndex - The index of the value to be removed from the selected list or single value\n * @param selected - The current (list of) selected value(s)\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\n * @returns - The updated `selected` with the enum option value at `valueIndex` in `allEnumOptions` removed from it,\n *        unless `selected` is a single value. In that case, if the `valueIndex` value matches `selected`, returns\n *        undefined, otherwise `selected`.\n */\nexport default function enumOptionsDeselectValue<S extends StrictRJSFSchema = RJSFSchema>(\n  valueIndex: string | number,\n  selected?: EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][],\n  allEnumOptions: EnumOptionsType<S>[] = []\n): EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][] | undefined {\n  const value = enumOptionsValueForIndex<S>(valueIndex, allEnumOptions);\n  if (Array.isArray(selected)) {\n    return selected.filter((v) => !isEqual(v, value));\n  }\n  return isEqual(value, selected) ? undefined : selected;\n}\n","import isEqual from 'lodash/isEqual';\n\nimport { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Determines whether the given `value` is (one of) the `selected` value(s).\n *\n * @param value - The value being checked to see if it is selected\n * @param selected - The current selected value or list of values\n * @returns - true if the `value` is one of the `selected` ones, false otherwise\n */\nexport default function enumOptionsIsSelected<S extends StrictRJSFSchema = RJSFSchema>(\n  value: EnumOptionsType<S>['value'],\n  selected: EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][]\n) {\n  if (Array.isArray(selected)) {\n    return selected.some((sel) => isEqual(sel, value));\n  }\n  return isEqual(selected, value);\n}\n","import { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\nimport enumOptionsIsSelected from './enumOptionsIsSelected';\n\n/** Returns the index(es) of the options in `allEnumOptions` whose value(s) match the ones in `value`. All the\n * `enumOptions` are filtered based on whether they are a \"selected\" `value` and the index of each selected one is then\n * stored in an array. If `multiple` is true, that array is returned, otherwise the first element in the array is\n * returned.\n *\n * @param value - The single value or list of values for which indexes are desired\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\n * @param [multiple=false] - Optional flag, if true will return a list of index, otherwise a single one\n * @returns - A single string index for the first `value` in `allEnumOptions`, if not `multiple`. Otherwise, the list\n *        of indexes for (each of) the value(s) in `value`.\n */\nexport default function enumOptionsIndexForValue<S extends StrictRJSFSchema = RJSFSchema>(\n  value: EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][],\n  allEnumOptions: EnumOptionsType<S>[] = [],\n  multiple = false\n): string | string[] | undefined {\n  const selectedIndexes: string[] = allEnumOptions\n    .map((opt, index) => (enumOptionsIsSelected(opt.value, value) ? String(index) : undefined))\n    .filter((opt) => typeof opt !== 'undefined') as string[];\n  if (!multiple) {\n    return selectedIndexes[0];\n  }\n  return selectedIndexes;\n}\n","import { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\nimport enumOptionsValueForIndex from './enumOptionsValueForIndex';\n\n/** Add the enum option value at the `valueIndex` to the list of `selected` values in the proper order as defined by\n * `allEnumOptions`\n *\n * @param valueIndex - The index of the value that should be selected\n * @param selected - The current list of selected values\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\n * @returns - The updated list of selected enum values with enum value at the `valueIndex` added to it\n */\nexport default function enumOptionsSelectValue<S extends StrictRJSFSchema = RJSFSchema>(\n  valueIndex: string | number,\n  selected: EnumOptionsType<S>['value'][],\n  allEnumOptions: EnumOptionsType<S>[] = []\n) {\n  const value = enumOptionsValueForIndex<S>(valueIndex, allEnumOptions);\n  if (value) {\n    const index = allEnumOptions.findIndex((opt) => value === opt.value);\n    const all = allEnumOptions.map(({ value: val }) => val);\n    const updated = selected.slice(0, index).concat(value, selected.slice(index));\n    // As inserting values at predefined index positions doesn't work with empty\n    // arrays, we need to reorder the updated selection to match the initial order\n    return updated.sort((a, b) => Number(all.indexOf(a) > all.indexOf(b)));\n  }\n  return selected;\n}\n","import cloneDeep from 'lodash/cloneDeep';\nimport get from 'lodash/get';\nimport set from 'lodash/set';\n\nimport { ErrorSchema } from './types';\nimport { ERRORS_KEY } from './constants';\n\n/** The `ErrorSchemaBuilder<T>` is used to build an `ErrorSchema<T>` since the definition of the `ErrorSchema` type is\n * designed for reading information rather than writing it. Use this class to add, replace or clear errors in an error\n * schema by using either dotted path or an array of path names. Once you are done building the `ErrorSchema`, you can\n * get the result and/or reset all the errors back to an initial set and start again.\n */\nexport default class ErrorSchemaBuilder<T = any> {\n  /** The error schema being built\n   *\n   * @private\n   */\n  private errorSchema: ErrorSchema<T> = {};\n\n  /** Construct an `ErrorSchemaBuilder` with an optional initial set of errors in an `ErrorSchema`.\n   *\n   * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class\n   */\n  constructor(initialSchema?: ErrorSchema<T>) {\n    this.resetAllErrors(initialSchema);\n  }\n\n  /** Returns the `ErrorSchema` that has been updated by the methods of the `ErrorSchemaBuilder`\n   */\n  get ErrorSchema() {\n    return this.errorSchema;\n  }\n\n  /** Will get an existing `ErrorSchema` at the specified `pathOfError` or create and return one.\n   *\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)\n   * @returns - The error block for the given `pathOfError` or the root if not provided\n   * @private\n   */\n  private getOrCreateErrorBlock(pathOfError?: string | string[]) {\n    const hasPath = (Array.isArray(pathOfError) && pathOfError.length > 0) || typeof pathOfError === 'string';\n    let errorBlock: ErrorSchema = hasPath ? get(this.errorSchema, pathOfError) : this.errorSchema;\n    if (!errorBlock && pathOfError) {\n      errorBlock = {};\n      set(this.errorSchema, pathOfError, errorBlock);\n    }\n    return errorBlock;\n  }\n\n  /** Resets all errors in the `ErrorSchemaBuilder` back to the `initialSchema` if provided, otherwise an empty set.\n   *\n   * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\n   */\n  resetAllErrors(initialSchema?: ErrorSchema<T>) {\n    this.errorSchema = initialSchema ? cloneDeep(initialSchema) : {};\n    return this;\n  }\n\n  /** Adds the `errorOrList` to the list of errors in the `ErrorSchema` at either the root level or the location within\n   * the schema described by the `pathOfError`. For more information about how to specify the path see the\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\n   *\n   * @param errorOrList - The error or list of errors to add into the `ErrorSchema`\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\n   */\n  addErrors(errorOrList: string | string[], pathOfError?: string | string[]) {\n    const errorBlock: ErrorSchema = this.getOrCreateErrorBlock(pathOfError);\n    let errorsList = get(errorBlock, ERRORS_KEY);\n    if (!Array.isArray(errorsList)) {\n      errorsList = [];\n      errorBlock[ERRORS_KEY] = errorsList;\n    }\n\n    if (Array.isArray(errorOrList)) {\n      errorsList.push(...errorOrList);\n    } else {\n      errorsList.push(errorOrList);\n    }\n    return this;\n  }\n\n  /** Sets/replaces the `errorOrList` as the error(s) in the `ErrorSchema` at either the root level or the location\n   * within the schema described by the `pathOfError`. For more information about how to specify the path see the\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\n   *\n   * @param errorOrList - The error or list of errors to set into the `ErrorSchema`\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to set the error(s)\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\n   */\n  setErrors(errorOrList: string | string[], pathOfError?: string | string[]) {\n    const errorBlock: ErrorSchema = this.getOrCreateErrorBlock(pathOfError);\n    // Effectively clone the array being given to prevent accidental outside manipulation of the given list\n    const listToAdd = Array.isArray(errorOrList) ? [...errorOrList] : [errorOrList];\n    set(errorBlock, ERRORS_KEY, listToAdd);\n    return this;\n  }\n\n  /** Clears the error(s) in the `ErrorSchema` at either the root level or the location within the schema described by\n   * the `pathOfError`. For more information about how to specify the path see the\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\n   *\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to clear the error(s)\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\n   */\n  clearErrors(pathOfError?: string | string[]) {\n    const errorBlock: ErrorSchema = this.getOrCreateErrorBlock(pathOfError);\n    set(errorBlock, ERRORS_KEY, []);\n    return this;\n  }\n}\n","import { RangeSpecType, StrictRJSFSchema } from './types';\nimport { RJSFSchema } from './types';\n\n/** Extracts the range spec information `{ step?: number, min?: number, max?: number }` that can be spread onto an HTML\n * input from the range analog in the schema `{ multipleOf?: number, minimum?: number, maximum?: number }`.\n *\n * @param schema - The schema from which to extract the range spec\n * @returns - A range specification from the schema\n */\nexport default function rangeSpec<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  const spec: RangeSpecType = {};\n  if (schema.multipleOf) {\n    spec.step = schema.multipleOf;\n  }\n  if (schema.minimum || schema.minimum === 0) {\n    spec.min = schema.minimum;\n  }\n  if (schema.maximum || schema.maximum === 0) {\n    spec.max = schema.maximum;\n  }\n  return spec;\n}\n","import rangeSpec from './rangeSpec';\nimport { FormContextType, InputPropsType, RJSFSchema, StrictRJSFSchema, UIOptionsType } from './types';\n\n/** Using the `schema`, `defaultType` and `options`, extract out the props for the <input> element that make sense.\n *\n * @param schema - The schema for the field provided by the widget\n * @param [defaultType] - The default type, if any, for the field provided by the widget\n * @param [options={}] - The UI Options for the field provided by the widget\n * @param [autoDefaultStepAny=true] - Determines whether to auto-default step=any when the type is number and no step\n * @returns - The extracted `InputPropsType` object\n */\nexport default function getInputProps<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  schema: RJSFSchema,\n  defaultType?: string,\n  options: UIOptionsType<T, S, F> = {},\n  autoDefaultStepAny = true\n): InputPropsType {\n  const inputProps: InputPropsType = {\n    type: defaultType || 'text',\n    ...rangeSpec(schema),\n  };\n\n  // If options.inputType is set use that as the input type\n  if (options.inputType) {\n    inputProps.type = options.inputType;\n  } else if (!defaultType) {\n    // If the schema is of type number or integer, set the input type to number\n    if (schema.type === 'number') {\n      inputProps.type = 'number';\n      // Only add step if one isn't already defined and we are auto-defaulting the \"any\" step\n      if (autoDefaultStepAny && inputProps.step === undefined) {\n        // Setting step to 'any' fixes a bug in Safari where decimals are not\n        // allowed in number inputs\n        inputProps.step = 'any';\n      }\n    } else if (schema.type === 'integer') {\n      inputProps.type = 'number';\n      // Only add step if one isn't already defined\n      if (inputProps.step === undefined) {\n        // Since this is integer, you always want to step up or down in multiples of 1\n        inputProps.step = 1;\n      }\n    }\n  }\n\n  if (options.autocomplete) {\n    inputProps.autoComplete = options.autocomplete;\n  }\n\n  return inputProps;\n}\n","import { SUBMIT_BTN_OPTIONS_KEY } from './constants';\nimport getUiOptions from './getUiOptions';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema, UISchemaSubmitButtonOptions } from './types';\n\n/** The default submit button options, exported for testing purposes\n */\nexport const DEFAULT_OPTIONS: UISchemaSubmitButtonOptions = {\n  props: {\n    disabled: false,\n  },\n  submitText: 'Submit',\n  norender: false,\n};\n\n/** Extracts any `ui:submitButtonOptions` from the `uiSchema` and merges them onto the `DEFAULT_OPTIONS`\n *\n * @param [uiSchema={}] - the UI Schema from which to extract submit button props\n * @returns - The merging of the `DEFAULT_OPTIONS` with any custom ones\n */\nexport default function getSubmitButtonOptions<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(uiSchema: UiSchema<T, S, F> = {}): UISchemaSubmitButtonOptions {\n  const uiOptions = getUiOptions<T, S, F>(uiSchema);\n  if (uiOptions && uiOptions[SUBMIT_BTN_OPTIONS_KEY]) {\n    const options = uiOptions[SUBMIT_BTN_OPTIONS_KEY] as UISchemaSubmitButtonOptions;\n    return { ...DEFAULT_OPTIONS, ...options };\n  }\n\n  return DEFAULT_OPTIONS;\n}\n","import { FormContextType, TemplatesType, Registry, UIOptionsType, StrictRJSFSchema, RJSFSchema } from './types';\n\n/** Returns the template with the given `name` from either the `uiSchema` if it is defined or from the `registry`\n * otherwise. NOTE, since `ButtonTemplates` are not overridden in `uiSchema` only those in the `registry` are returned.\n *\n * @param name - The name of the template to fetch, restricted to the keys of `TemplatesType`\n * @param registry - The `Registry` from which to read the template\n * @param [uiOptions={}] - The `UIOptionsType` from which to read an alternate template\n * @returns - The template from either the `uiSchema` or `registry` for the `name`\n */\nexport default function getTemplate<\n  Name extends keyof TemplatesType<T, S, F>,\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(name: Name, registry: Registry<T, S, F>, uiOptions: UIOptionsType<T, S, F> = {}): TemplatesType<T, S, F>[Name] {\n  const { templates } = registry;\n  if (name === 'ButtonTemplates') {\n    return templates[name];\n  }\n  return (\n    // Evaluating uiOptions[name] results in TS2590: Expression produces a union type that is too complex to represent\n    // To avoid that, we cast uiOptions to `any` before accessing the name field\n    ((uiOptions as any)[name] as TemplatesType<T, S, F>[Name]) || templates[name]\n  );\n}\n","import { createElement } from 'react';\nimport ReactIs from 'react-is';\nimport get from 'lodash/get';\nimport set from 'lodash/set';\n\nimport { FormContextType, RJSFSchema, Widget, RegistryWidgetsType, StrictRJSFSchema } from './types';\nimport getSchemaType from './getSchemaType';\n\n/** The map of schema types to widget type to widget name\n */\nconst widgetMap: { [k: string]: { [j: string]: string } } = {\n  boolean: {\n    checkbox: 'CheckboxWidget',\n    radio: 'RadioWidget',\n    select: 'SelectWidget',\n    hidden: 'HiddenWidget',\n  },\n  string: {\n    text: 'TextWidget',\n    password: 'PasswordWidget',\n    email: 'EmailWidget',\n    hostname: 'TextWidget',\n    ipv4: 'TextWidget',\n    ipv6: 'TextWidget',\n    uri: 'URLWidget',\n    'data-url': 'FileWidget',\n    radio: 'RadioWidget',\n    select: 'SelectWidget',\n    textarea: 'TextareaWidget',\n    hidden: 'HiddenWidget',\n    date: 'DateWidget',\n    datetime: 'DateTimeWidget',\n    'date-time': 'DateTimeWidget',\n    'alt-date': 'AltDateWidget',\n    'alt-datetime': 'AltDateTimeWidget',\n    time: 'TimeWidget',\n    color: 'ColorWidget',\n    file: 'FileWidget',\n  },\n  number: {\n    text: 'TextWidget',\n    select: 'SelectWidget',\n    updown: 'UpDownWidget',\n    range: 'RangeWidget',\n    radio: 'RadioWidget',\n    hidden: 'HiddenWidget',\n  },\n  integer: {\n    text: 'TextWidget',\n    select: 'SelectWidget',\n    updown: 'UpDownWidget',\n    range: 'RangeWidget',\n    radio: 'RadioWidget',\n    hidden: 'HiddenWidget',\n  },\n  array: {\n    select: 'SelectWidget',\n    checkboxes: 'CheckboxesWidget',\n    files: 'FileWidget',\n    hidden: 'HiddenWidget',\n  },\n};\n\n/** Wraps the given widget with stateless functional component that will merge any `defaultProps.options` with the\n * `options` that are provided in the props. It will add the wrapper component as a `MergedWidget` property onto the\n * `Widget` so that future attempts to wrap `AWidget` will return the already existing wrapper.\n *\n * @param AWidget - A widget that will be wrapped or one that is already wrapped\n * @returns - The wrapper widget\n */\nfunction mergeWidgetOptions<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  AWidget: Widget<T, S, F>\n) {\n  let MergedWidget: Widget<T, S, F> | undefined = get(AWidget, 'MergedWidget');\n  // cache return value as property of widget for proper react reconciliation\n  if (!MergedWidget) {\n    const defaultOptions = (AWidget.defaultProps && AWidget.defaultProps.options) || {};\n    MergedWidget = ({ options, ...props }) => {\n      return <AWidget options={{ ...defaultOptions, ...options }} {...props} />;\n    };\n    set(AWidget, 'MergedWidget', MergedWidget);\n  }\n  return MergedWidget;\n}\n\n/** Given a schema representing a field to render and either the name or actual `Widget` implementation, returns the\n * React component that is used to render the widget. If the `widget` is already a React component, then it is wrapped\n * with a `MergedWidget`. Otherwise an attempt is made to look up the widget inside of the `registeredWidgets` map based\n * on the schema type and `widget` name. If no widget component can be found an `Error` is thrown.\n *\n * @param schema - The schema for the field\n * @param [widget] - Either the name of the widget OR a `Widget` implementation to use\n * @param [registeredWidgets={}] - A registry of widget name to `Widget` implementation\n * @returns - The `Widget` component to use\n * @throws - An error if there is no `Widget` component that can be returned\n */\nexport default function getWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  schema: RJSFSchema,\n  widget?: Widget<T, S, F> | string,\n  registeredWidgets: RegistryWidgetsType<T, S, F> = {}\n): Widget<T, S, F> {\n  const type = getSchemaType(schema);\n\n  if (\n    typeof widget === 'function' ||\n    (widget && ReactIs.isForwardRef(createElement(widget))) ||\n    ReactIs.isMemo(widget)\n  ) {\n    return mergeWidgetOptions<T, S, F>(widget as Widget<T, S, F>);\n  }\n\n  if (typeof widget !== 'string') {\n    throw new Error(`Unsupported widget definition: ${typeof widget}`);\n  }\n\n  if (widget in registeredWidgets) {\n    const registeredWidget = registeredWidgets[widget];\n    return getWidget<T, S, F>(schema, registeredWidget, registeredWidgets);\n  }\n\n  if (typeof type === 'string') {\n    if (!(type in widgetMap)) {\n      throw new Error(`No widget for type '${type}'`);\n    }\n\n    if (widget in widgetMap[type]) {\n      const registeredWidget = registeredWidgets[widgetMap[type][widget]];\n      return getWidget<T, S, F>(schema, registeredWidget, registeredWidgets);\n    }\n  }\n\n  throw new Error(`No widget '${widget}' for type '${type}'`);\n}\n","import getWidget from './getWidget';\nimport { FormContextType, RegistryWidgetsType, RJSFSchema, StrictRJSFSchema, Widget } from './types';\n\n/** Detects whether the `widget` exists for the `schema` with the associated `registryWidgets` and returns true if it\n * does, or false if it doesn't.\n *\n * @param schema - The schema for the field\n * @param widget - Either the name of the widget OR a `Widget` implementation to use\n * @param [registeredWidgets={}] - A registry of widget name to `Widget` implementation\n * @returns - True if the widget exists, false otherwise\n */\nexport default function hasWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  schema: RJSFSchema,\n  widget: Widget<T, S, F> | string,\n  registeredWidgets: RegistryWidgetsType<T, S, F> = {}\n) {\n  try {\n    getWidget(schema, widget, registeredWidgets);\n    return true;\n  } catch (e) {\n    const err: Error = e as Error;\n    if (err.message && (err.message.startsWith('No widget') || err.message.startsWith('Unsupported widget'))) {\n      return false;\n    }\n    throw e;\n  }\n}\n","import isString from 'lodash/isString';\n\nimport { IdSchema } from './types';\nimport { ID_KEY } from './constants';\n\n/** Generates a consistent `id` pattern for a given `id` and a `suffix`\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @param suffix - The suffix to append to the id\n */\nfunction idGenerator<T = any>(id: IdSchema<T> | string, suffix: string) {\n  const theId = isString(id) ? id : id[ID_KEY];\n  return `${theId}__${suffix}`;\n}\n/** Return a consistent `id` for the field description element\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @returns - The consistent id for the field description element from the given `id`\n */\nexport function descriptionId<T = any>(id: IdSchema<T> | string) {\n  return idGenerator<T>(id, 'description');\n}\n\n/** Return a consistent `id` for the field error element\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @returns - The consistent id for the field error element from the given `id`\n */\nexport function errorId<T = any>(id: IdSchema<T> | string) {\n  return idGenerator<T>(id, 'error');\n}\n\n/** Return a consistent `id` for the field examples element\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @returns - The consistent id for the field examples element from the given `id`\n */\nexport function examplesId<T = any>(id: IdSchema<T> | string) {\n  return idGenerator<T>(id, 'examples');\n}\n\n/** Return a consistent `id` for the field help element\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @returns - The consistent id for the field help element from the given `id`\n */\nexport function helpId<T = any>(id: IdSchema<T> | string) {\n  return idGenerator<T>(id, 'help');\n}\n\n/** Return a consistent `id` for the field title element\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @returns - The consistent id for the field title element from the given `id`\n */\nexport function titleId<T = any>(id: IdSchema<T> | string) {\n  return idGenerator<T>(id, 'title');\n}\n\n/** Return a list of element ids that contain additional information about the field that can be used to as the aria\n * description of the field. This is correctly omitting `titleId` which would be \"labeling\" rather than \"describing\" the\n * element.\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @param [includeExamples=false] - Optional flag, if true, will add the `examplesId` into the list\n * @returns - The string containing the list of ids for use in an `aria-describedBy` attribute\n */\nexport function ariaDescribedByIds<T = any>(id: IdSchema<T> | string, includeExamples = false) {\n  const examples = includeExamples ? ` ${examplesId<T>(id)}` : '';\n  return `${errorId<T>(id)} ${descriptionId<T>(id)} ${helpId<T>(id)}${examples}`;\n}\n\n/** Return a consistent `id` for the `optionIndex`s of a `Radio` or `Checkboxes` widget\n *\n * @param id - The id of the parent component for the option\n * @param optionIndex - The index of the option for which the id is desired\n * @returns - An id for the option index based on the parent `id`\n */\nexport function optionId(id: string, optionIndex: number) {\n  return `${id}-${optionIndex}`;\n}\n","import { ReactElement } from 'react';\n\n/** Helper function that will return the value to use for a widget `label` based on `hideLabel`. The `fallback` is used\n * as the return value from the function when `hideLabel` is true. Due to the implementation of theme components, it\n * may be necessary to return something other than `undefined` to cause the theme component to not render a label. Some\n * themes require may `false` and others may require and empty string.\n *\n * @param [label] - The label string or component to render when not hidden\n * @param [hideLabel] - Flag, if true, will cause the label to be hidden\n * @param [fallback] - One of 3 values, `undefined` (the default), `false` or an empty string\n * @returns - `fallback` if `hideLabel` is true, otherwise `label`\n */\nexport function labelValue(label?: string | ReactElement, hideLabel?: boolean, fallback?: ''): undefined | string;\nexport default function labelValue(label?: string | ReactElement, hideLabel?: boolean, fallback?: false | '') {\n  return hideLabel ? fallback : label;\n}\n","/** Converts a local Date string into a UTC date string\n *\n * @param dateString - The string representation of a date as accepted by the `Date()` constructor\n * @returns - A UTC date string if `dateString` is truthy, otherwise undefined\n */\nexport default function localToUTC(dateString: string) {\n  return dateString ? new Date(dateString).toJSON() : undefined;\n}\n","import { CONST_KEY, ENUM_KEY } from './constants';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Returns the constant value from the schema when it is either a single value enum or has a const key. Otherwise\n * throws an error.\n *\n * @param schema - The schema from which to obtain the constant value\n * @returns - The constant value for the schema\n * @throws - Error when the schema does not have a constant value\n */\nexport default function toConstant<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  if (ENUM_KEY in schema && Array.isArray(schema.enum) && schema.enum.length === 1) {\n    return schema.enum[0];\n  }\n  if (CONST_KEY in schema) {\n    return schema.const;\n  }\n  throw new Error('schema cannot be inferred as a constant');\n}\n","import toConstant from './toConstant';\nimport { RJSFSchema, EnumOptionsType, StrictRJSFSchema } from './types';\n\n/** Gets the list of options from the schema. If the schema has an enum list, then those enum values are returned. The\n * labels for the options will be extracted from the non-standard, RJSF-deprecated `enumNames` if it exists, otherwise\n * the label will be the same as the `value`. If the schema has a `oneOf` or `anyOf`, then the value is the list of\n * `const` values from the schema and the label is either the `schema.title` or the value.\n *\n * @param schema - The schema from which to extract the options list\n * @returns - The list of options from the schema\n */\nexport default function optionsList<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S\n): EnumOptionsType<S>[] | undefined {\n  // enumNames was deprecated in v5 and is intentionally omitted from the RJSFSchema type.\n  // Cast the type to include enumNames so the feature still works.\n  const schemaWithEnumNames = schema as S & { enumNames?: string[] };\n  if (schemaWithEnumNames.enumNames && process.env.NODE_ENV !== 'production') {\n    console.warn('The enumNames property is deprecated and may be removed in a future major release.');\n  }\n  if (schema.enum) {\n    return schema.enum.map((value, i) => {\n      const label = (schemaWithEnumNames.enumNames && schemaWithEnumNames.enumNames[i]) || String(value);\n      return { label, value };\n    });\n  }\n  const altSchemas = schema.oneOf || schema.anyOf;\n  return (\n    altSchemas &&\n    altSchemas.map((aSchemaDef) => {\n      const aSchema = aSchemaDef as S;\n      const value = toConstant(aSchema);\n      const label = aSchema.title || String(value);\n      return {\n        schema: aSchema,\n        label,\n        value,\n      };\n    })\n  );\n}\n","import { GenericObjectType } from './types';\n\n/** Given a list of `properties` and an `order` list, returns a list that contains the `properties` ordered correctly.\n * If `order` is not an array, then the untouched `properties` list is returned. Otherwise `properties` is ordered per\n * the `order` list. If `order` contains a '*' then any `properties` that are not mentioned explicity in `order` will be\n * places in the location of the `*`.\n *\n * @param properties - The list of property keys to be ordered\n * @param order - An array of property keys to be ordered first, with an optional '*' property\n * @returns - A list with the `properties` ordered\n * @throws - Error when the properties cannot be ordered correctly\n */\nexport default function orderProperties(properties: string[], order?: string[]): string[] {\n  if (!Array.isArray(order)) {\n    return properties;\n  }\n\n  const arrayToHash = (arr: string[]) =>\n    arr.reduce((prev: GenericObjectType, curr) => {\n      prev[curr] = true;\n      return prev;\n    }, {});\n  const errorPropList = (arr: string[]) =>\n    arr.length > 1 ? `properties '${arr.join(\"', '\")}'` : `property '${arr[0]}'`;\n  const propertyHash = arrayToHash(properties);\n  const orderFiltered = order.filter((prop) => prop === '*' || propertyHash[prop]);\n  const orderHash = arrayToHash(orderFiltered);\n\n  const rest = properties.filter((prop: string) => !orderHash[prop]);\n  const restIndex = orderFiltered.indexOf('*');\n  if (restIndex === -1) {\n    if (rest.length) {\n      throw new Error(`uiSchema order list does not contain ${errorPropList(rest)}`);\n    }\n    return orderFiltered;\n  }\n  if (restIndex !== orderFiltered.lastIndexOf('*')) {\n    throw new Error('uiSchema order list contains more than one wildcard item');\n  }\n\n  const complete = [...orderFiltered];\n  complete.splice(restIndex, 1, ...rest);\n  return complete;\n}\n","/** Returns a string representation of the `num` that is padded with leading \"0\"s if necessary\n *\n * @param num - The number to pad\n * @param width - The width of the string at which no lead padding is necessary\n * @returns - The number converted to a string with leading zero padding if the number of digits is less than `width`\n */\nexport default function pad(num: number, width: number) {\n  let s = String(num);\n  while (s.length < width) {\n    s = '0' + s;\n  }\n  return s;\n}\n","import { DateObject } from './types';\n\n/** Parses the `dateString` into a `DateObject`, including the time information when `includeTime` is true\n *\n * @param dateString - The date string to parse into a DateObject\n * @param [includeTime=true] - Optional flag, if false, will not include the time data into the object\n * @returns - The date string converted to a `DateObject`\n * @throws - Error when the date cannot be parsed from the string\n */\nexport default function parseDateString(dateString?: string, includeTime = true): DateObject {\n  if (!dateString) {\n    return {\n      year: -1,\n      month: -1,\n      day: -1,\n      hour: includeTime ? -1 : 0,\n      minute: includeTime ? -1 : 0,\n      second: includeTime ? -1 : 0,\n    };\n  }\n  const date = new Date(dateString);\n  if (Number.isNaN(date.getTime())) {\n    throw new Error('Unable to parse date ' + dateString);\n  }\n  return {\n    year: date.getUTCFullYear(),\n    month: date.getUTCMonth() + 1, // oh you, javascript.\n    day: date.getUTCDate(),\n    hour: includeTime ? date.getUTCHours() : 0,\n    minute: includeTime ? date.getUTCMinutes() : 0,\n    second: includeTime ? date.getUTCSeconds() : 0,\n  };\n}\n","import { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Check to see if a `schema` specifies that a value must be true. This happens when:\n * - `schema.const` is truthy\n * - `schema.enum` == `[true]`\n * - `schema.anyOf` or `schema.oneOf` has a single value which recursively returns true\n * - `schema.allOf` has at least one value which recursively returns true\n *\n * @param schema - The schema to check\n * @returns - True if the schema specifies a value that must be true, false otherwise\n */\nexport default function schemaRequiresTrueValue<S extends StrictRJSFSchema = RJSFSchema>(schema: S): boolean {\n  // Check if const is a truthy value\n  if (schema.const) {\n    return true;\n  }\n\n  // Check if an enum has a single value of true\n  if (schema.enum && schema.enum.length === 1 && schema.enum[0] === true) {\n    return true;\n  }\n\n  // If anyOf has a single value, evaluate the subschema\n  if (schema.anyOf && schema.anyOf.length === 1) {\n    return schemaRequiresTrueValue(schema.anyOf[0] as S);\n  }\n\n  // If oneOf has a single value, evaluate the subschema\n  if (schema.oneOf && schema.oneOf.length === 1) {\n    return schemaRequiresTrueValue(schema.oneOf[0] as S);\n  }\n\n  // Evaluate each subschema in allOf, to see if one of them requires a true value\n  if (schema.allOf) {\n    const schemaSome = (subSchema: S['additionalProperties']) => schemaRequiresTrueValue(subSchema as S);\n    return schema.allOf.some(schemaSome);\n  }\n\n  return false;\n}\n","import React from 'react';\n\nimport deepEquals from './deepEquals';\n\n/** Determines whether the given `component` should be rerendered by comparing its current set of props and state\n * against the next set. If either of those two sets are not the same, then the component should be rerendered.\n *\n * @param component - A React component being checked\n * @param nextProps - The next set of props against which to check\n * @param nextState - The next set of state against which to check\n * @returns - True if the component should be re-rendered, false otherwise\n */\nexport default function shouldRender(component: React.Component, nextProps: any, nextState: any) {\n  const { props, state } = component;\n  return !deepEquals(props, nextProps) || !deepEquals(state, nextState);\n}\n","import { DateObject } from './types';\n\n/** Returns a UTC date string for the given `dateObject`. If `time` is false, then the time portion of the string is\n * removed.\n *\n * @param dateObject - The `DateObject` to convert to a date string\n * @param [time=true] - Optional flag used to remove the time portion of the date string if false\n * @returns - The UTC date string\n */\nexport default function toDateString(dateObject: DateObject, time = true) {\n  const { year, month, day, hour = 0, minute = 0, second = 0 } = dateObject;\n  const utcTime = Date.UTC(year, month - 1, day, hour, minute, second);\n  const datetime = new Date(utcTime).toJSON();\n  return time ? datetime : datetime.slice(0, 10);\n}\n","import pad from './pad';\n\n/** Converts a UTC date string into a local Date format\n *\n * @param jsonDate - A UTC date string\n * @returns - An empty string when `jsonDate` is falsey, otherwise a date string in local format\n */\nexport default function utcToLocal(jsonDate: string) {\n  if (!jsonDate) {\n    return '';\n  }\n\n  // required format of `'yyyy-MM-ddThh:mm' followed by optional ':ss' or ':ss.SSS'\n  // https://html.spec.whatwg.org/multipage/input.html#local-date-and-time-state-(type%3Ddatetime-local)\n  // > should be a _valid local date and time string_ (not GMT)\n\n  // Note - date constructor passed local ISO-8601 does not correctly\n  // change time to UTC in node pre-8\n  const date = new Date(jsonDate);\n\n  const yyyy = pad(date.getFullYear(), 4);\n  const MM = pad(date.getMonth() + 1, 2);\n  const dd = pad(date.getDate(), 2);\n  const hh = pad(date.getHours(), 2);\n  const mm = pad(date.getMinutes(), 2);\n  const ss = pad(date.getSeconds(), 2);\n  const SSS = pad(date.getMilliseconds(), 3);\n\n  return `${yyyy}-${MM}-${dd}T${hh}:${mm}:${ss}.${SSS}`;\n}\n","/** An enumeration of all the translatable strings used by `@rjsf/core` and its themes. The value of each of the\n * enumeration keys is expected to be the actual english string. Some strings contain replaceable parameter values\n * as indicated by `%1`, `%2`, etc. The number after the `%` indicates the order of the parameter. The ordering of\n * parameters is important because some languages may choose to put the second parameter before the first in its\n * translation. Also, some strings are rendered using `markdown-to-jsx` and thus support markdown and inline html.\n */\nexport enum TranslatableString {\n  /** Fallback title of an array item, used by ArrayField */\n  ArrayItemTitle = 'Item',\n  /** Missing items reason, used by ArrayField */\n  MissingItems = 'Missing items definition',\n  /** Yes label, used by BooleanField */\n  YesLabel = 'Yes',\n  /** No label, used by BooleanField */\n  NoLabel = 'No',\n  /** Close label, used by ErrorList */\n  CloseLabel = 'Close',\n  /** Errors label, used by ErrorList */\n  ErrorsLabel = 'Errors',\n  /** New additionalProperties string default value, used by ObjectField */\n  NewStringDefault = 'New Value',\n  /** Add button title, used by AddButton */\n  AddButton = 'Add',\n  /** Add button title, used by AddButton */\n  AddItemButton = 'Add Item',\n  /** Copy button title, used by IconButton */\n  CopyButton = 'Copy',\n  /** Move down button title, used by IconButton */\n  MoveDownButton = 'Move down',\n  /** Move up button title, used by IconButton */\n  MoveUpButton = 'Move up',\n  /** Remove button title, used by IconButton */\n  RemoveButton = 'Remove',\n  /** Now label, used by AltDateWidget */\n  NowLabel = 'Now',\n  /** Clear label, used by AltDateWidget */\n  ClearLabel = 'Clear',\n  /** Aria date label, used by DateWidget */\n  AriaDateLabel = 'Select a date',\n  /** File preview label, used by FileWidget */\n  PreviewLabel = 'Preview',\n  /** Decrement button aria label, used by UpDownWidget */\n  DecrementAriaLabel = 'Decrease value by 1',\n  /** Increment button aria label, used by UpDownWidget */\n  IncrementAriaLabel = 'Increase value by 1',\n  // Strings with replaceable parameters\n  /** Unknown field type reason, where %1 will be replaced with the type as provided by SchemaField */\n  UnknownFieldType = 'Unknown field type %1',\n  /** Option prefix, where %1 will be replaced with the option index as provided by MultiSchemaField */\n  OptionPrefix = 'Option %1',\n  /** Option prefix, where %1 and %2 will be replaced by the schema title and option index, respectively as provided by\n   * MultiSchemaField\n   */\n  TitleOptionPrefix = '%1 option %2',\n  /** Key label, where %1 will be replaced by the label as provided by WrapIfAdditionalTemplate */\n  KeyLabel = '%1 Key',\n  // Strings with replaceable parameters AND/OR that support markdown and html\n  /** Invalid object field configuration as provided by the ObjectField */\n  InvalidObjectField = 'Invalid \"%1\" object field configuration: <em>%2</em>.',\n  /** Unsupported field schema, used by UnsupportedField */\n  UnsupportedField = 'Unsupported field schema.',\n  /** Unsupported field schema, where %1 will be replaced by the idSchema.$id as provided by UnsupportedField */\n  UnsupportedFieldWithId = 'Unsupported field schema for field <code>%1</code>.',\n  /** Unsupported field schema, where %1 will be replaced by the reason string as provided by UnsupportedField */\n  UnsupportedFieldWithReason = 'Unsupported field schema: <em>%1</em>.',\n  /** Unsupported field schema, where %1 and %2 will be replaced by the idSchema.$id and reason strings, respectively,\n   * as provided by UnsupportedField\n   */\n  UnsupportedFieldWithIdAndReason = 'Unsupported field schema for field <code>%1</code>: <em>%2</em>.',\n  /** File name, type and size info, where %1, %2 and %3 will be replaced by the file name, file type and file size as\n   * provided by FileWidget\n   */\n  FilesInfo = '<strong>%1</strong> (%2, %3 bytes)',\n}\n"],"names":["isObject","thing","File","Date","Array","isArray","allowAdditionalItems","schema","additionalItems","console","warn","asNumber","value","undefined","test","n","Number","valid","isNaN","ADDITIONAL_PROPERTY_FLAG","ADDITIONAL_PROPERTIES_KEY","ALL_OF_KEY","ANY_OF_KEY","CONST_KEY","DEFAULT_KEY","DEFINITIONS_KEY","DEPENDENCIES_KEY","ENUM_KEY","ERRORS_KEY","ID_KEY","ITEMS_KEY","NAME_KEY","ONE_OF_KEY","PROPERTIES_KEY","REQUIRED_KEY","SUBMIT_BTN_OPTIONS_KEY","REF_KEY","RJSF_ADDITONAL_PROPERTIES_FLAG","UI_FIELD_KEY","UI_WIDGET_KEY","UI_OPTIONS_KEY","UI_GLOBAL_OPTIONS_KEY","getUiOptions","uiSchema","globalOptions","Object","keys","filter","key","indexOf","reduce","options","_extends2","error","_extends","substring","canExpand","formData","additionalProperties","_getUiOptions","_getUiOptions$expanda","expandable","maxProperties","length","deepEquals","a","b","isEqualWith","obj","other","splitKeyElementFromObject","object","remaining","omit","findSchemaDefinition","$ref","rootSchema","ref","startsWith","decodeURIComponent","Error","current","jsonpointer","get","_splitKeyElementFromO","theRef","subSchema","getMatchingOption","validator","i","option","properties","requiresAnyOf","anyOf","map","required","augmentedSchema","shallowClone","_objectDestructuringEmpty","allOf","slice","push","assign","isValid","getFirstMatchingOption","guessType","getSchemaType","type","includes","find","mergeSchemas","obj1","obj2","acc","left","right","union","resolveCondition","expression","then","otherwise","resolvedSchemaLessConditional","_objectWithoutPropertiesLoose","_excluded","conditionalSchema","retrieveSchema","resolveSchema","resolveReference","resolvedSchema","resolveDependencies","allOfSubschema","$refSchema","localSchema","_excluded2","stubExistingAdditionalProperties","theSchema","aFormData","forEach","set","rawFormData","mergeAllOf","deep","e","_resolvedSchema","resolvedSchemaWithoutAllOf","_excluded3","hasAdditionalProperties","dependencies","remainingSchema","_excluded4","oneOf","processDependencies","dependencyKey","remainingDependencies","dependencyValue","withDependentProperties","withDependentSchema","additionallyRequired","from","Set","concat","_retrieveSchema","dependentSchema","_excluded5","resolvedOneOf","subschema","withExactlyOneSubschema","validSubschemas","conditionPropertySchema","_properties","conditionSchema","_validator$validateFo","validateFormData","errors","_splitKeyElementFromO2","dependentSubschema","JUNK_OPTION","__not_really_there__","calculateIndexScore","totalScore","score","formValue","has","newSchema","getClosestMatchingOption","newScore","isString","selectedOption","allValidIndexes","validList","index","testOptions","match","times","_allValidIndexes$redu","scoreData","bestScore","bestIndex","isFixedItems","items","every","item","mergeDefaultsWithFormData","defaults","defaultsArray","mapped","idx","mergeObjects","concatArrays","toMerge","result","isConstant","isSelect","altSchemas","isMultiSelect","uniqueItems","AdditionalItemsHandling","getInnerSchemaForArrayItem","Ignore","maybeAddDefaultToObject","computedDefault","includeUndefinedValues","requiredFields","isEmpty","computeDefaults","rawSchema","parentDefaults","refSchema","itemSchema","objectDefaults","additionalPropertiesSchema","schemaItem","Fallback","minItems","defaultsLength","defaultEntries","fillerSchema","Invert","fillerDefault","fillerEntries","fill","getDefaultFormState","isCustomWidget","isFilesArray","itemsSchema","format","getDisplayLabel","uiOptions","_uiOptions$label","label","displayLabel","schemaType","mergeValidationData","validationData","additionalErrorSchema","oldErrors","oldErrorSchema","errorSchema","toErrorList","NO_VALUE","Symbol","sanitizeDataForNewSchema","oldSchema","data","newFormData","removeOldSchemaData","nestedData","oldKeyedSchema","newKeyedSchema","oldSchemaTypeForKey","newSchemaTypeForKey","itemData","newOptionDefault","oldOptionDefault","newOptionConst","oldOptionConst","oldSchemaItems","newSchemaItems","oldSchemaType","newSchemaType","maxItems","newValue","aValue","itemValue","toIdSchema","id","idPrefix","idSeparator","_schema","$id","idSchema","name","field","fieldId","toPathSchema","_pathSchema","pathSchema","replace","element","property","SchemaUtils","_proto","prototype","getValidator","doesSchemaUtilsDiffer","createSchemaUtils","dataURItoBlob","dataURI","splitted","split","params","param","decodeURI","binary","atob","array","charCodeAt","blob","window","Blob","Uint8Array","size","message","replaceStringParameters","inputString","output","parts","partIndex","findIndex","part","join","englishStringTranslator","stringToTranslate","enumOptionsValueForIndex","valueIndex","allEnumOptions","emptyValue","val","enumOptionsDeselectValue","selected","v","isEqual","enumOptionsIsSelected","some","sel","enumOptionsIndexForValue","multiple","selectedIndexes","opt","String","enumOptionsSelectValue","all","_ref","updated","sort","ErrorSchemaBuilder","initialSchema","resetAllErrors","getOrCreateErrorBlock","pathOfError","hasPath","errorBlock","cloneDeep","addErrors","errorOrList","errorsList","_errorsList","apply","setErrors","listToAdd","clearErrors","_createClass","rangeSpec","spec","multipleOf","step","minimum","min","maximum","max","getInputProps","defaultType","autoDefaultStepAny","inputProps","inputType","autocomplete","autoComplete","DEFAULT_OPTIONS","props","disabled","submitText","norender","getSubmitButtonOptions","getTemplate","registry","templates","widgetMap","checkbox","radio","select","hidden","string","text","password","email","hostname","ipv4","ipv6","uri","textarea","date","datetime","time","color","file","number","updown","range","integer","checkboxes","files","mergeWidgetOptions","AWidget","MergedWidget","defaultOptions","defaultProps","_jsx","getWidget","widget","registeredWidgets","ReactIs","isForwardRef","createElement","isMemo","registeredWidget","hasWidget","err","idGenerator","suffix","theId","descriptionId","errorId","examplesId","helpId","titleId","ariaDescribedByIds","includeExamples","examples","optionId","optionIndex","labelValue","hideLabel","fallback","localToUTC","dateString","toJSON","toConstant","optionsList","schemaWithEnumNames","enumNames","process","aSchemaDef","aSchema","title","orderProperties","order","arrayToHash","arr","prev","curr","errorPropList","propertyHash","orderFiltered","prop","orderHash","rest","restIndex","lastIndexOf","complete","splice","pad","num","width","s","parseDateString","includeTime","year","month","day","hour","minute","second","getTime","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","schemaRequiresTrueValue","schemaSome","shouldRender","component","nextProps","nextState","state","toDateString","dateObject","_dateObject$hour","_dateObject$minute","_dateObject$second","utcTime","UTC","utcToLocal","jsonDate","yyyy","getFullYear","MM","getMonth","dd","getDate","hh","getHours","mm","getMinutes","ss","getSeconds","SSS","getMilliseconds","TranslatableString"],"mappings":"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"}